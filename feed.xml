<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://bwfbowen.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bwfbowen.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-08T08:34:17+00:00</updated><id>https://bwfbowen.github.io/feed.xml</id><title type="html">Bowen Fang</title><subtitle>The personal academic website of Bowen Fang. </subtitle><entry><title type="html">Some Recent Advancement Around MuZero</title><link href="https://bwfbowen.github.io/blog/2023/blog-more-mcts/" rel="alternate" type="text/html" title="Some Recent Advancement Around MuZero"/><published>2023-10-29T00:00:00+00:00</published><updated>2023-10-29T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2023/blog-more-mcts</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2023/blog-more-mcts/"><![CDATA[<p><img src="/assets/img/limit-muzero.png" alt="Limitation of MuZero" width="500" height="300"/></p> <p>I have found 4 interesting papers that discover and address the limitations of MuZero. <a href="https://proceedings.neurips.cc/paper_files/paper/2021/hash/d5eca8dc3820cad9fe56a3bafda65ca1-Abstract.html">EfficientZero</a> and <a href="https://proceedings.mlr.press/v119/grill20a.html">MCTS as regularized policy optimization</a> improve the algorithm itself; <a href="https://proceedings.mlr.press/v139/hubert21a.html">SampledMuZero</a> and <a href="https://openreview.net/forum?id=X6D9bAHhBQ1">StochasticMuZero</a> extend the algorithm into a new setting that the original algorithm is not able to perform well.</p> <h1 id="efficientzerolink">EfficientZero<a href="https://proceedings.neurips.cc/paper_files/paper/2021/hash/d5eca8dc3820cad9fe56a3bafda65ca1-Abstract.html">Link</a></h1> <p>The author finds that in limited-data setting, for instance, Atari 100K, which is 2 hours of real-time game experience, MuZero is not that impressive in performance. This leads the author to observe 3 issues.</p> <ol> <li>Lack of supervision on environment model. In previous MCTS RL algorithms, the environment model is either given or only trained with rewards, values, and policies, which cannot provide sufficient training signals due to their scalar nature. The problem is more severe when the reward is sparse or the bootstrapped value is not accurate. The MCTS policy improvement operator heavily relies on the environment model. Thus, it is vital to have an accurate one.</li> <li>Predicting the reward from a state is a hard problem. If we only see the first observation, along with future actions, it is very hard both for an agent and a human to predict at which exact future timestep the player would lose a point. However, it is easy to predict the agent will miss the ball after a sufficient number of timesteps if he does not move. In practice, a human will never try to predict the exact step that he loses the point but will imagine over a longer horizon and thus get a more confident prediction.</li> <li>This value target suffers from off-policy issues, since the trajectory is rolled out using an older policy, and thus the value target is no longer accurate. When data is limited, we have to reuse the data sampled from a much older policy, thus exaggerating the inaccurate value target issue.</li> </ol> <p><img src="/assets/img/effi-limi2.png" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 1. To predict at which exact future timestep the player would lose a point could be hard, but it is easy to predict the agent will miss the ball after a sufficient number of timesteps if he does not move </figcaption> </figure> <p>Then 3 methods are proposed to solve each of the issues.</p> <p>The first one is self-supervised to provide more information. The idea is illustrated by the Figure 2. That is, the hidden state from dynamic function should be similar to the hidden state from the representation of the next observation.</p> <p><img src="/assets/img/self-consistent.png" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 2. The self-supervised consistency loss </figcaption> </figure> <p>The second is to predict value prefix, which is discounted sum of rewards, instead of stepwise reward. The author chose the LSTM for value prefix prediction. During the training time, the LSTM is supervised at every time step, since the value prefix can be computed whenever a new state comes in. This per-step rich supervision allows the LSTM can be trained well even with limited data.</p> <p>The third is to re-run MCTS for an adjusted TD steps based on the age of the trajectory. the value target is computed by sampling a trajectory from the replay buffer and computing: \(z_t=\sum_{i=0}^{k-1}\gamma^i u_{t+i}+\gamma^k v_{t+k}\) This value target suffers from off-policy issues, since the trajectory is rolled out using an older policy, and thus the value target is no longer accurate. The author proposed to use rewards of a dynamic horizon $l$ from the old trajectory, where $l&lt;k$ and $l$ should be smaller if the trajectory is older.</p> <h1 id="mcts-as-regularized-policy-optimizationlink">MCTS as regularized policy optimization<a href="https://proceedings.mlr.press/v119/grill20a.html">Link</a></h1> <p>This paper focuses on policy improvement, and proposed a new method to <em>act</em>, <em>search</em> and <em>update</em> for AlphaZero.</p> <p>They started from policy optimization, which aims at finding a globally optimal policy $\pi_\theta$, generally using iterative updates. Each updates the current policy $\pi_\theta$ by solving a local maximization problem of the form \(\pi_{\theta'}≜\arg\max_{\textbf{y}\in \mathcal{S}}\mathcal{Q}^T_{\pi_\theta}\textbf{y}-\mathcal{R}(\textbf{y}, \pi_\theta)\), several model-free algorithms employ such policy optimization, for instance, TRPO and MPO set $\mathcal{R}$ to be the KL-divergence between consecutive policies. With idea from policy optimization, they proposed a new policy for AlphaZero: \(\newcommand{\kl}{\mathrm{KL}} \bar{\pi}\triangleq\arg\max_{\textbf{y}\in \mathcal{S}}[\textbf{q}^T\textbf{y}-\lambda_N\kl[\pi_\theta,\textbf{y}] ]\), which in practical can be computed as: \(\bar{\pi}=λ_N\frac{\pi_θ}{α-\textbf{q}}\), where $\alpha$ is used to make $\bar{\pi}$ a proper probability vector and is found through dichotomic search over $(\alpha_{min},\alpha_{max})$, whose value is defined as: \(\alpha_{min}≜\max_{b\in \mathcal{A}}(q[b]+\lambda_N·\pi_\theta[b]), α_{max}≜\max_{b\in\mathcal{A}}q[b]+\lambda_N\).</p> <p>Then they argued that the empirical visit count distribution $\hat{\pi}$: \(\hat{\pi}(a\mid x)≜\frac{1+n(x,a)}{\mid \mathcal{A}\mid \sum_bn(x,b)}\), has several shortcomings. The first is the efficiency. When a promising new (high-value) leaf is discovered, many additional simulations might be needed before this information is reflected in $\hat{\pi}$; since $\bar{\pi}$ is directly computed from Q-values, this information is updated instantly. The second is the expressiveness. $\hat{\pi}$ is simply the ratio of two integers, and thus has limited expressiveness when the simulation budget is low. The third is that the prior $\pi_\theta$ is trained against the target $\hat{\pi}$, but the latter is only improved for actions that have been sampled at least once during search. This may be problematic for certain actions that would require a large simulation budget to be sampled even once.</p> <p>The new policy is applied for acting, searching and learning process of AlphaZero.</p> <ol> <li>ACT: AlphaZero acts in the real environment by sampling actions according to \(a ∼ \hat{π}(·\ x_{root})\). Instead, they proposed to sample actions sampling according to \(a ∼ \bar{π}(·\mid x_{root})\).</li> <li>SEARCH: During search, they proposed to stochastically sample actions according to $\bar{\pi}$ instead of the deterministic action selection rule. At each node x in the tree, $\bar{π}(·)$ is computed with Q-values and total visit counts at the node.</li> <li>LEARN: AlphaZero computes locally improved policy with tree search and distills such improved policy into $π_θ$. They proposed to use $\bar{π}$ as the target policy in place of $\hat{π}$ to train prior policy</li> </ol> <h1 id="stochastic-muzerolink">Stochastic MuZero<a href="https://openreview.net/forum?id=X6D9bAHhBQ1">Link</a></h1> <p>This paper proposed a method to generalize MuZero to learn and plan in stochastic environment. The idea is to factorize the stochastic state transitions into two deterministic transitions, the first is action $a_t$ conditioned transition from state $s_t$ to afterstate $as_t$(the hypothetical state after the action is applied but before the environment transitions to the next state), the second is a stochastic transition from $as_t$ to the next state $s_{t+1}$ guided by a chance outcome $c_t^i$.</p> <p><img src="/assets/img/afterstate.webp" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <p>The proposed method applies modifications to planning and learning phases of MuZero. Figure 3 shows the search of Stochastic MuZero, where diamond nodes represent chance nodes and circular nodes represent decision nodes. Edges are selected by applying the pUCT formula in the case of decision nodes, and by sampling the prior $σ$ in the case of chance nodes.</p> <p><img src="/assets/img/search.webp" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 3. Monte Carlo Tree Search used in Stochastic MuZero. </figcaption> </figure> <p>Figure 4 demonstrates the training process of Stochastic MuZero. During the unroll, the encoder $e$ receives the observation as input and generates a chance code $c_{t+k}$ deterministically. The policy, value and reward are trained towards the target \(\pi_{t+k}, z_{t+k}, u_{t+k}\) as MuZero does. The distribution $\sigma_k$ over future codes are trained to predict the code produced by the encoder.</p> <p><img src="/assets/img/training.webp" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 4. Training of stochastic model in Stochastic MuZero. Here for a given trajectory of length 2 with observations $o_{≤t:t+2}$, actions $a_{t:t+2}$, value targets $z_{t:t+2}$, policy targets $π_{t:t+2}$ and rewards $u_{t+1:t+K}$, the model is unrolled for 2 steps. </figcaption> </figure> <p>The loss is given by the MuZero loss and a chance loss:</p> \[L_w^{chance}=\sum_{k=0}^{K-1}l^Q(z_{t+k},Q_t^k)+\sum_{k=0}^{K-1}l^{σ}(c_{t+k+1},σ^k_t)+β\sum_{k=0}^{K-1}\|c_{t+k+1}-c_{t+k+1}^e\|^2\] <p>During inference, given the initial observation \(o_{≤t}\) and actions \(a_{t:t+K}\), trajectories from the model can be generated recurrently by unrolling it and by sampling chance outcomes from the distribution \(c_{t+k+1}∼σ_t^k\).</p> <h1 id="sampled-muzerolink">Sampled MuZero<a href="https://proceedings.mlr.press/v139/hubert21a.html">Link</a></h1> <p>This paper focuses on the limitation of MuZero that it can not be applied to action spaces that cannot be easily enumerated or are not discrete. The method proposed in this paper extends MuZero to the case of arbitrary action spaces.</p> <p>The proposed method is to sample a subset of actions for the search and the training:</p> <p><img src="/assets/img/sampled-muzero-improvement.webp" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 5. On the left, the current policy π(a|s). Next, K actions are sampled from a proposal distribution β and βˆ(a|s) is the corresponding empirical distribution. A sample-based improved policy Iˆβπ(a|s) = (βˆ/β)(a|s)f(s,a,Zˆβ(s)) is then built. As the number of samples K increases Iˆβπ(a|s) converges to the improved policy Iπ(a|s). </figcaption> </figure> <ol> <li>Each time a leaf node is expanded, <em>Sampled MuZero</em> samples $K«N$ actions from a distribution $β$, where the paper uses $β=π$</li> <li>MCTS produces an improved distribution \(\hat{I}_β π(a\mid s)\) over the sampled actions. To avoid double counting of probabilities and remain stable, the UCB formula uses \(\frac{\hat{\beta}}{\beta}\pi\) instead of raw $\pi$. The policy is updated on this sampled improvement.</li> </ol>]]></content><author><name></name></author><category term="EfficientZero"/><category term="SampledMuZero"/><category term="StochasticMuZero"/><category term="MCTS"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">MPC with a Differentiable Forward Model: An Implementation with Jax</title><link href="https://bwfbowen.github.io/blog/2023/blog-mpc/" rel="alternate" type="text/html" title="MPC with a Differentiable Forward Model: An Implementation with Jax"/><published>2023-06-20T00:00:00+00:00</published><updated>2023-06-20T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2023/blog-mpc</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2023/blog-mpc/"><![CDATA[<p><img src="/assets/img/animation_mpc.png" alt="mpc control" width="300" height="200"/></p> <h1 id="intro">Intro</h1> <p>In a recent project for MECS6616 Robot Learning, I got hands-on experience for Model Predictive Control (MPC). To solve the problem, the use of constant action and pseudo-gradient is a recommended method, and it truly provides simple yet good enough solutions. However, the project instructions also hinted at another prospect: a differentiable forward model could help, since you can always compute numerical gradients. This piqued my curiosity - could we directly compute the gradient with respect to action given the evaluation metric? And if so, how could we implement this practically?</p> <p>With these questions in mind, I embarked on a journey to explore the use of differentiable programming in the context of MPC. My tool of choice was Jax, a high-performance machine learning library. The journey in the end, however, reveals that direct calculation of numerical gradients from the target metric doesn’t necessarily equate to better performance. This realization reminded me of a 2017 <a href="https://openai.com/research/evolution-strategies">paper</a> by OpenAI on evolution strategies, which I would like to share in the future.</p> <p>In this blog&amp;tutorial, I’ll share my implementation and provide a step-by-step guide to implementing MPC with a differentiable forward model using Jax.</p> <h1 id="background">Background</h1> <h2 id="mpc">MPC</h2> <p>Model Predictive Control (MPC) is a control strategy that involves the use of an optimization algorithm to determine the optimal control inputs to a system. The optimization problem is formulated based on a model of the system, a cost function, and constraints on the system states and inputs. The control inputs from the optimal solution are then applied to the system, and the process is repeated at the next time step. This strategy allows MPC to anticipate future events and act accordingly.</p> <h3 id="forward-model">Forward model</h3> <p>The forward model, which is a function that takes the current state of the system and the action given to the robot as input, and outputs the next state of the system.</p> \[x_{k+1}=f(x_k,u_k)\] <p>Where \(x_k\) is the state of the system at time step $k$, \(u_k\) is the action / command given to the robot at time step $k$.</p> <h3 id="cost-function-and-goal">Cost function and Goal</h3> <p>Cost functions can be user-defined, for instance, the cost function \(j(x,u)\) is the cost of a state and action, \(j_F(x)\) is the cost of the terminal state. The goal is the optimization objective, and the target is to find an action sequence that minimize the objective. A goal $j$ could be: \(J=\sum_{i=k}^{N-1}j(x_i,u_i)+j_F(x_N)\), where $N$ is the control horizon.</p> <h2 id="jax">JAX</h2> <p>JAX is a Python library developed by Google that provides capabilities for efficient and easily differentiable numerical computation. JAX extends the familiar NumPy interface with automatic differentiation, enabling users to compute gradients with minimal changes to their code. It also includes support for just-in-time compilation via XLA, making it possible to develop efficient, speed-optimized code in Python.</p> <p>I think the coolest feature of JAX is the <code class="language-plaintext highlighter-rouge">grad</code>, which differentiate a function. Here is a simple example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span> 
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">grad</span>

<span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">grad_tanh</span> <span class="o">=</span> <span class="nf">grad</span><span class="p">(</span><span class="n">tanh</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grad_tanh</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="c1"># 0.070650816
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">grad</code> takes a function and returns a function. If you have a Python function <code class="language-plaintext highlighter-rouge">f</code> that evaluates the mathematical function , then <code class="language-plaintext highlighter-rouge">grad(f)</code> is a Python function that evaluates the mathematical function \(\nabla f\). That means <code class="language-plaintext highlighter-rouge">grad(f)(x)</code> represents the value \(\nabla f(x)\).</p> <p>And since <code class="language-plaintext highlighter-rouge">grad</code> operates on functions, you can apply it to its own output to differentiate as many times as you like:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="n">tanh</span><span class="p">))(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="n">tanh</span><span class="p">)))(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="c1"># -0.13621868
# 0.25265405
</span></code></pre></div></div> <h1 id="implementation">Implementation</h1> <h2 id="problem-formulation">Problem formulation</h2> <p>Given an n linked robot arm and the ground truth forward dynamics, the target is to design a controller that could minimizes the distance of end effector to the goal position and the velocity of the end effector at the terminal state.</p> <p>In a colab notebook:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">!</span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">roamlab</span><span class="o">/</span><span class="n">mecs6616_sp23_project4</span><span class="p">.</span><span class="n">git</span>
<span class="err">!</span><span class="n">mv</span> <span class="o">/</span><span class="n">content</span><span class="o">/</span><span class="n">mecs6616_sp23_project4</span><span class="o">/*</span> <span class="o">/</span><span class="n">content</span><span class="o">/</span>
<span class="err">!</span><span class="n">pip</span> <span class="n">install</span> <span class="n">ray</span>
</code></pre></div></div> <p>The differentiable forward model is implemented as below:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">jax</span> 
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span> 
<span class="kn">from</span> <span class="n">arm_dynamics_teacher</span> <span class="kn">import</span> <span class="n">ArmDynamicsTeacher</span>
<span class="kn">from</span> <span class="n">geometry</span> <span class="kn">import</span> <span class="n">rot</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span>


<span class="k">class</span> <span class="nc">DifferentiableArmDynamicsTeacher</span><span class="p">(</span><span class="n">ArmDynamicsTeacher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dynamics_step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Forward simulation using Euler method </span><span class="sh">"""</span>
        <span class="n">left_hand</span><span class="p">,</span> <span class="n">right_hand</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">constraint_matrices</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">qdd</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">right_hand</span><span class="p">)</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">integrate_euler</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">qdd</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_state</span>

    <span class="k">def</span> <span class="nf">constraint_matrices</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Contructs the constraint matrices from state </span><span class="sh">"""</span>
        <span class="c1"># Computes variables dependent on state required to construct constraint matrices
</span>        <span class="n">num_vars</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_q</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_theta</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">qd</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_qd</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_omega</span><span class="p">(</span><span class="n">qd</span><span class="p">)</span>
        <span class="n">vel_0</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_vel_0</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_vel</span><span class="p">(</span><span class="n">vel_0</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">vel_com</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_vel_com</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>

        <span class="n">left_hand</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">right_hand</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Force equilibrium constraints
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">))</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="nf">rot</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># gravity
</span>            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">gravity</span><span class="p">:</span>
                <span class="n">cr</span> <span class="o">=</span> <span class="n">cr</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="mf">9.8</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_masses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="nf">rot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nf">yaxis</span><span class="p">())))</span>
            <span class="c1"># centrifugal force
</span>            <span class="n">cr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_masses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left_hand</span> <span class="o">=</span> <span class="n">cl</span>
                <span class="n">right_hand</span> <span class="o">=</span> <span class="n">cr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">cl</span><span class="p">))</span>
                <span class="n">right_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">right_hand</span><span class="p">,</span> <span class="n">cr</span><span class="p">))</span>

        <span class="c1"># Torque equilibrium constraints
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">))</span>
            <span class="c1"># the y component of the force
</span>            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="c1"># inertial torque
</span>            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_inertias</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># the y component
</span>                <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_f</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nf">rot</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">left_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">cl</span><span class="p">))</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">right_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">right_hand</span><span class="p">,</span> <span class="n">cr</span><span class="p">))</span>
            <span class="c1"># viscous friction depends on the mode, implemented in ArmDynamics &amp; SnakeDynamics
</span>
        <span class="c1"># Linear acceleration constraints
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">))</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nf">rot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="nf">rot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nf">yaxis</span><span class="p">())))</span>
            <span class="n">left_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">cl</span><span class="p">))</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="nf">rot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nf">xaxis</span><span class="p">())))</span>
            <span class="n">right_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">right_hand</span><span class="p">,</span> <span class="n">cr</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">left_hand</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">right_hand</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Joint viscous friction
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">right_hand</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_tau_eqbm</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">qd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">joint_viscous_friction</span>

        <span class="c1"># Linear acceleration of joint-0 must be zero
</span>        <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()))</span>
        <span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">left_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">cl</span><span class="p">))</span>
        <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">right_hand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">((</span><span class="n">right_hand</span><span class="p">,</span> <span class="n">cr</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">left_hand</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">right_hand</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply torques 
</span>        <span class="n">right_hand</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">right_hand</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">action</span>
        <span class="n">tau_shift</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">roll</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">shift</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tau_shift</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">tau_diff</span> <span class="o">=</span> <span class="n">tau_shift</span> <span class="o">-</span> <span class="n">tau</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">right_hand</span> <span class="o">=</span> <span class="n">right_hand</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_tau_eqbm</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="n">tau_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">left_hand</span><span class="p">,</span> <span class="n">right_hand</span>
    
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">left_hand</span><span class="p">,</span> <span class="n">right_hand</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Solves the constraint matrices to compute accelerations </span><span class="sh">"""</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">right_hand</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">residue</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">right_hand</span><span class="p">)</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">left_hand</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">right_hand</span><span class="p">)</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_var</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">residue</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">residue_limit</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">cannot solve, residue {} exceeds limit {}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">residue_limit</span><span class="p">))</span>
            <span class="n">self</span><span class="p">.</span><span class="n">residue_limit_flag</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_a</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">)]</span>
        <span class="n">omdot</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="n">self</span><span class="p">.</span><span class="nf">idx_omdot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">)]</span>
        <span class="n">qdd</span> <span class="o">=</span> <span class="n">omdot</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">qdd</span> <span class="o">=</span> <span class="n">qdd</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="o">-</span><span class="n">qdd</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">qdd</span>

    <span class="k">def</span> <span class="nf">integrate_euler</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">qdd</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s"> Integrates using Euler method </span><span class="sh">"""</span>
        <span class="c1"># Compute state dependent variables needed for integration
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_q</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">qd</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_qd</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">qd_new</span> <span class="o">=</span> <span class="n">qd</span> <span class="o">+</span> <span class="n">qdd</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">q_new</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">qd</span> <span class="o">+</span> <span class="n">qd_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="n">new_state</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">vstack</span><span class="p">([</span><span class="n">q_new</span><span class="p">,</span> <span class="n">qd_new</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_state</span>
    
    <span class="k">def</span> <span class="nf">compute_theta</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_pos</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos_0</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pos_0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">pos</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nf">xaxis</span><span class="p">()))</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">vstack</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>
    
    <span class="k">def</span> <span class="nf">compute_fk</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">pos_0</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_pos_0</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_q</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_theta</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_pos</span><span class="p">(</span><span class="n">pos_0</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">pos_ee</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">pos_ee</span> <span class="o">=</span> <span class="n">pos_ee</span> <span class="o">+</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">num_links</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nf">xaxis</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">pos_ee</span>
    
    <span class="k">def</span> <span class="nf">compute_vel</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vel_0</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vel</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">vel_0</span><span class="p">)</span>
        <span class="n">vel_world</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vel_world</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">vel_0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_links</span><span class="p">):</span>
            <span class="n">vel_world</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">vel_world</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">rot</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">link_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nf">yaxis</span><span class="p">())))</span>
            <span class="n">vel</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">rot</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">vel_world</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">vstack</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vel</span>
    
    <span class="k">def</span> <span class="nf">rot</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="n">jnp</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">jnp</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                       <span class="p">[</span><span class="n">jnp</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]]).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span>

</code></pre></div></div> <p>Based on the differentiable forward model, the MPC is implemented as:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">import</span> <span class="n">random</span>
<span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">calc_dist</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">next_state</span> <span class="o">=</span> <span class="n">dynamics</span><span class="p">.</span><span class="nf">dynamics_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">pos_ee</span> <span class="o">=</span> <span class="n">dynamics</span><span class="p">.</span><span class="nf">compute_fk</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">goal</span> <span class="o">-</span> <span class="n">pos_ee</span><span class="p">)</span>
    <span class="c1"># vel_ee = jnp.linalg.norm(arm.dynamics.compute_vel_ee(next_state))
</span>    <span class="k">return</span> <span class="n">dist</span>

<span class="k">class</span> <span class="nc">MPC</span><span class="p">:</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>
               <span class="n">time_limit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">,</span> 
               <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> 
               <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
               <span class="n">num_controls</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="n">self</span><span class="p">.</span><span class="n">control_horizon</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="c1"># Define other parameters here
</span>    <span class="n">self</span><span class="p">.</span><span class="n">num_steps</span> <span class="o">=</span> <span class="nf">round</span><span class="p">(</span><span class="n">time_limit</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">num_controls</span> <span class="o">=</span> <span class="nf">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_steps</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">control_horizon</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">num_controls</span> <span class="k">else</span> <span class="n">num_controls</span>
    <span class="n">self</span><span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>

  <span class="k">def</span> <span class="nf">compute_action</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
    <span class="c1"># Put your code here. You must return an array of shape (num_links, 1)
</span>
    <span class="c1"># Don't forget to comment out the line below
</span>    <span class="c1"># raise NotImplementedError("MPC not implemented")
</span>    <span class="n">best_action</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_planning</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best_action</span>

  <span class="k">def</span> <span class="nf">_planning</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">initial_state</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">num_controls</span><span class="p">):</span>
      <span class="n">state</span> <span class="o">=</span> <span class="n">dynamics</span><span class="p">.</span><span class="nf">dynamics_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">dt</span><span class="p">)</span>
      <span class="n">gradient</span> <span class="o">+=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">calc_dist</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">action</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">dt</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">grad: </span><span class="si">{</span><span class="n">gradient</span><span class="si">}</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">action: </span><span class="si">{</span><span class="n">action</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">best_action</span> <span class="o">=</span> <span class="n">action</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">scale</span>
    <span class="k">return</span> <span class="n">best_action</span>
    
</code></pre></div></div> <p>To test the MPC controller, you can use this part of code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">arm_dynamics_teacher</span> <span class="kn">import</span> <span class="n">ArmDynamicsTeacher</span>
<span class="kn">from</span> <span class="n">robot</span> <span class="kn">import</span> <span class="n">Robot</span>
<span class="kn">from</span> <span class="n">render</span> <span class="kn">import</span> <span class="n">Renderer</span>
<span class="kn">from</span> <span class="n">score</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="n">np</span><span class="p">.</span><span class="nf">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="c1"># Teacher arm with 3 links
</span><span class="n">dynamics_teacher</span> <span class="o">=</span> <span class="nc">DifferentiableArmDynamicsTeacher</span><span class="p">(</span>
    <span class="n">num_links</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">link_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">link_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">joint_viscous_friction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="n">arm</span> <span class="o">=</span> <span class="nc">Robot</span><span class="p">(</span><span class="n">dynamics_teacher</span><span class="p">)</span>
<span class="n">arm</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

<span class="n">gui</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">if</span> <span class="n">gui</span><span class="p">:</span>
  <span class="n">renderer</span> <span class="o">=</span> <span class="nc">Renderer</span><span class="p">()</span>
  <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Controller
</span><span class="n">controller</span> <span class="o">=</span> <span class="nc">MPC</span><span class="p">(</span><span class="n">time_limit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">num_controls</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

<span class="c1"># Resetting the arm will set its state so that it is in the vertical position,
# and set the action to be zeros
</span><span class="n">arm</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

<span class="c1"># Choose the goal position you would like to see the performance of your controller
</span><span class="n">goal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="n">goal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.7</span>
<span class="n">arm</span><span class="p">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">time_limit</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="nf">round</span><span class="p">(</span><span class="n">time_limit</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># Control loop
</span><span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
  <span class="n">arm</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">gui</span><span class="p">:</span>
    <span class="n">renderer</span><span class="p">.</span><span class="nf">plot</span><span class="p">([(</span><span class="n">arm</span><span class="p">,</span> <span class="sh">"</span><span class="s">tab:blue</span><span class="sh">"</span><span class="p">)])</span>
  <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dt</span> <span class="o">-</span> <span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="n">controller</span><span class="p">.</span><span class="n">control_horizon</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">arm</span><span class="p">.</span><span class="nf">get_state</span><span class="p">()</span>

    <span class="c1"># Measuring distance and velocity of end effector
</span>    <span class="n">pos_ee</span> <span class="o">=</span> <span class="n">dynamics_teacher</span><span class="p">.</span><span class="nf">compute_fk</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">goal</span><span class="o">-</span><span class="n">pos_ee</span><span class="p">)</span>
    <span class="n">vel_ee</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">arm</span><span class="p">.</span><span class="n">dynamics</span><span class="p">.</span><span class="nf">compute_vel_ee</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">At timestep </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s">: Distance to goal: </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s">, Velocity of end effector: </span><span class="si">{</span><span class="n">vel_ee</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="nf">compute_action</span><span class="p">(</span><span class="n">arm</span><span class="p">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
    <span class="c1"># print(f'Action: {action}')
</span>    <span class="n">arm</span><span class="p">.</span><span class="nf">set_action</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="JAX"/><category term="MPC"/><category term="Differentiable"/><category term="Robot Learning"/><summary type="html"><![CDATA[Intro In a recent project for MECS6616 Robot Learning, I got hands-on experience for Model Predictive Control (MPC). To solve the problem, the use of constant action and pseudo-gradient is a recommended method, and it truly provides simple yet good enough solutions. However, the project instructions also hinted at another prospect: a differentiable forward model could help, since you can always compute numerical gradients. This piqued my curiosity - could we directly compute the gradient with respect to action given the evaluation metric? And if so, how could we implement this practically?]]></summary></entry><entry><title type="html">Adding MuZero into RL Toolkits at Ease</title><link href="https://bwfbowen.github.io/blog/2023/blog-muax/" rel="alternate" type="text/html" title="Adding MuZero into RL Toolkits at Ease"/><published>2023-05-12T00:00:00+00:00</published><updated>2023-05-12T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2023/blog-muax</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2023/blog-muax/"><![CDATA[<p><img src="/assets/img/cart-pole-muax.gif" alt="Gym environment examples: Cart Pole" width="250" height="150"/> <img src="/assets/img/lunar-lander-muax.gif" alt="Gym environment examples: Lunar Lander" width="250" height="150"/></p> <h1 id="muax-">MUAX 😘</h1> <p>Muax provides help for using DeepMind’s <a href="https://github.com/deepmind/mctx">mctx</a> on gym-style environments.</p> <h2 id="installation">Installation</h2> <p>You can install the released version of muax through PyPI:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>muax
</code></pre></div></div> <h2 id="getting-started">Getting started</h2> <p>Muax provides some functions around <a href="https://github.com/deepmind/mctx">mctx</a>’s high-level policy <code class="language-plaintext highlighter-rouge">muzero_policy</code>. The usage of muax could be similar to using policies like DQN, PPO and etc. For instance, in a typical loop for interacting with the environment, the code is like(code snippet from <a href="https://github.com/bwfbowen/muax/blob/main/muax/test.py">muax/test</a>):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">random_seed</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
<span class="n">obs</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)</span>
<span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">episode_reward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">spec</span><span class="p">.</span><span class="n">max_episode_steps</span><span class="p">):</span>
    <span class="n">key</span><span class="p">,</span> <span class="n">subkey</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">act</span><span class="p">(</span><span class="n">subkey</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> 
                  <span class="n">num_simulations</span><span class="o">=</span><span class="n">num_simulations</span><span class="p">,</span>
                  <span class="n">temperature</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># Use deterministic actions during testing
</span>    <span class="n">obs_next</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">episode_reward</span> <span class="o">+=</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">truncated</span><span class="p">:</span>
        <span class="k">break</span> 
    <span class="n">obs</span> <span class="o">=</span> <span class="n">obs_next</span>
</code></pre></div></div> <p>Check <a href="https://github.com/bwfbowen/muax/blob/main/examples/cartpole.ipynb">cartpole.ipynb</a> for a basic training example(The notebook should be runnable on colab).</p> <p>1.To train a MuZero model, the user needs to define the <code class="language-plaintext highlighter-rouge">representation_fn</code>, <code class="language-plaintext highlighter-rouge">prediction_fn</code> and <code class="language-plaintext highlighter-rouge">dynamic_fn</code> with <a href="https://github.com/deepmind/dm-haiku">haiku</a>. <a href="https://github.com/bwfbowen/muax/blob/main/muax/nn.py">muax/nn</a> provides an example of defining an MLP with single hidden layer.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">jax</span> 
<span class="n">jax</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="sh">'</span><span class="s">jax_platform_name</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">cpu</span><span class="sh">'</span><span class="p">)</span>

<span class="kn">import</span> <span class="n">muax</span>
<span class="kn">from</span> <span class="n">muax</span> <span class="kn">import</span> <span class="n">nn</span> 

<span class="n">support_size</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">embedding_size</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">num_actions</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">full_support_size</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">support_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">repr_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_representation_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Representation</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">)</span>
<span class="n">pred_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_prediction_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Prediction</span><span class="p">,</span> <span class="n">num_actions</span><span class="p">,</span> <span class="n">full_support_size</span><span class="p">)</span>
<span class="n">dy_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_dynamic_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">,</span> <span class="n">num_actions</span><span class="p">,</span> <span class="n">full_support_size</span><span class="p">)</span>
</code></pre></div></div> <p>2.<code class="language-plaintext highlighter-rouge">muax</code> has built-in <code class="language-plaintext highlighter-rouge">episode tracer</code> and <code class="language-plaintext highlighter-rouge">replay buffuer</code> to track and store trajectories from interacting with environments. The first parameter of <code class="language-plaintext highlighter-rouge">muax.PNStep</code> (10 in the following code) is the <code class="language-plaintext highlighter-rouge">n</code> for n-step bootstrapping.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">discount</span> <span class="o">=</span> <span class="mf">0.99</span>
<span class="n">tracer</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">PNStep</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">TrajectoryReplayBuffer</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</code></pre></div></div> <p>3.<code class="language-plaintext highlighter-rouge">muax</code> leverages <code class="language-plaintext highlighter-rouge">optax</code> to build optimizer to update weights.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gradient_transform</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="nf">optimizer</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">peak_value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">end_value</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</code></pre></div></div> <p>4.Now we are ready to call <code class="language-plaintext highlighter-rouge">muax.fit</code> function to fit the model to the <code class="language-plaintext highlighter-rouge">CartPole</code> environment.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">MuZero</span><span class="p">(</span><span class="n">repr_fn</span><span class="p">,</span> <span class="n">pred_fn</span><span class="p">,</span> <span class="n">dy_fn</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="sh">'</span><span class="s">muzero</span><span class="sh">'</span><span class="p">,</span> <span class="n">discount</span><span class="o">=</span><span class="n">discount</span><span class="p">,</span>
                    <span class="n">optimizer</span><span class="o">=</span><span class="n">gradient_transform</span><span class="p">,</span> <span class="n">support_size</span><span class="o">=</span><span class="n">support_size</span><span class="p">)</span>

<span class="n">model_path</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="sh">'</span><span class="s">CartPole-v1</span><span class="sh">'</span><span class="p">,</span> 
                    <span class="n">max_episodes</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                    <span class="n">max_training_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                    <span class="n">tracer</span><span class="o">=</span><span class="n">tracer</span><span class="p">,</span>
                    <span class="nb">buffer</span><span class="o">=</span><span class="nb">buffer</span><span class="p">,</span>
                    <span class="n">k_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">sample_per_trajectory</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">num_trajectory</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                    <span class="n">tensorboard_dir</span><span class="o">=</span><span class="sh">'</span><span class="s">/content/tensorboard/cartpole</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">model_save_path</span><span class="o">=</span><span class="sh">'</span><span class="s">/content/models/cartpole</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">save_name</span><span class="o">=</span><span class="sh">'</span><span class="s">cartpole_model_params</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">random_seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">log_all_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <p>The full training script:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">muax</span>
<span class="kn">from</span> <span class="n">muax</span> <span class="kn">import</span> <span class="n">nn</span> 

<span class="n">support_size</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">embedding_size</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">discount</span> <span class="o">=</span> <span class="mf">0.99</span>
<span class="n">num_actions</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">full_support_size</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">support_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">repr_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_representation_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Representation</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">)</span>
<span class="n">pred_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_prediction_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Prediction</span><span class="p">,</span> <span class="n">num_actions</span><span class="p">,</span> <span class="n">full_support_size</span><span class="p">)</span>
<span class="n">dy_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">_init_dynamic_func</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">,</span> <span class="n">num_actions</span><span class="p">,</span> <span class="n">full_support_size</span><span class="p">)</span>

<span class="n">tracer</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">PNStep</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">TrajectoryReplayBuffer</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>

<span class="n">gradient_transform</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="nf">optimizer</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">peak_value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">end_value</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">warmup_steps</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">MuZero</span><span class="p">(</span><span class="n">repr_fn</span><span class="p">,</span> <span class="n">pred_fn</span><span class="p">,</span> <span class="n">dy_fn</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="sh">'</span><span class="s">muzero</span><span class="sh">'</span><span class="p">,</span> <span class="n">discount</span><span class="o">=</span><span class="n">discount</span><span class="p">,</span>
                    <span class="n">optimizer</span><span class="o">=</span><span class="n">gradient_transform</span><span class="p">,</span> <span class="n">support_size</span><span class="o">=</span><span class="n">support_size</span><span class="p">)</span>

<span class="n">model_path</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="sh">'</span><span class="s">CartPole-v1</span><span class="sh">'</span><span class="p">,</span> 
                    <span class="n">max_episodes</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                    <span class="n">max_training_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                    <span class="n">tracer</span><span class="o">=</span><span class="n">tracer</span><span class="p">,</span>
                    <span class="nb">buffer</span><span class="o">=</span><span class="nb">buffer</span><span class="p">,</span>
                    <span class="n">k_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">sample_per_trajectory</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">num_trajectory</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                    <span class="n">tensorboard_dir</span><span class="o">=</span><span class="sh">'</span><span class="s">/content/tensorboard/cartpole</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">model_save_path</span><span class="o">=</span><span class="sh">'</span><span class="s">/content/models/cartpole</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">save_name</span><span class="o">=</span><span class="sh">'</span><span class="s">cartpole_model_params</span><span class="sh">'</span><span class="p">,</span>
                    <span class="n">random_seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">log_all_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <p>5.After the training is done, one can use tensorboard to check the training procedure.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">load_ext</span> <span class="n">tensorboard</span> 
<span class="o">%</span><span class="n">tensorboard</span> <span class="o">--</span><span class="n">logdir</span><span class="o">=</span><span class="n">tensorboard</span><span class="o">/</span><span class="n">cartpole</span>
</code></pre></div></div> <p>In the figure below, the model is able to solve the environment in ~500 episodes, ~30k updates <img src="/assets/img/tensorboard_example.png" alt="tensorboard example"/></p> <p>6.We can also have more tests with the best parameter</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">muax.test</span> <span class="kn">import</span> <span class="n">test</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">muax</span><span class="p">.</span><span class="nc">MuZero</span><span class="p">(</span><span class="n">repr_fn</span><span class="p">,</span> <span class="n">pred_fn</span><span class="p">,</span> <span class="n">dy_fn</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="sh">'</span><span class="s">muzero</span><span class="sh">'</span><span class="p">,</span> <span class="n">discount</span><span class="o">=</span><span class="n">discount</span><span class="p">,</span>
                    <span class="n">optimizer</span><span class="o">=</span><span class="n">gradient_transform</span><span class="p">,</span> <span class="n">support_size</span><span class="o">=</span><span class="n">support_size</span><span class="p">)</span>

<span class="n">model</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

<span class="n">env_id</span> <span class="o">=</span> <span class="sh">'</span><span class="s">CartPole-v1</span><span class="sh">'</span>
<span class="n">test_env</span> <span class="o">=</span> <span class="n">gym</span><span class="p">.</span><span class="nf">make</span><span class="p">(</span><span class="n">env_id</span><span class="p">,</span> <span class="n">render_mode</span><span class="o">=</span><span class="sh">'</span><span class="s">rgb_array</span><span class="sh">'</span><span class="p">)</span>
<span class="n">test_key</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">test</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_env</span><span class="p">,</span> <span class="n">test_key</span><span class="p">,</span> <span class="n">num_simulations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">num_test_episodes</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div> <p>Alternatively, the users could easily write their own training loop. One example is from <a href="https://github.com/bwfbowen/muax/blob/main/examples/cartpole.ipynb">cartpole.ipynb</a></p> <p>More examples can be found under the <a href="https://github.com/bwfbowen/muax/tree/main/examples">example</a> directory.</p>]]></content><author><name></name></author><category term="JAX"/><category term="MuZero"/><category term="MCTS"/><summary type="html"><![CDATA[MUAX 😘 Muax provides help for using DeepMind’s mctx on gym-style environments.]]></summary></entry><entry><title type="html">“Hindsight” – An easy yet effective RL Technique HER with Pytorch implementation</title><link href="https://bwfbowen.github.io/blog/2022/blog-hindsight/" rel="alternate" type="text/html" title="“Hindsight” – An easy yet effective RL Technique HER with Pytorch implementation"/><published>2022-05-18T00:00:00+00:00</published><updated>2022-05-18T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2022/blog-hindsight</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2022/blog-hindsight/"><![CDATA[<p>This week, I will share a paper published by OpenAI at NeurIPS 2017. The ideas presented in this paper are quite insightful, and it tackles a complex problem using only simple algorithmic improvements. I gained significant inspiration from this paper. At the end, I will also provide a brief implementation of HER (Hindsight Experience Replay).</p> <blockquote> <p>Original Paper Information <br/> <strong>Title</strong>: Hindsight experience replay <br/> <strong>Author</strong>: Marcin Andrychowicz, Filip Wolski, Alex Ray, Jonas Schneider, Rachel Fong, Peter Welinder, Bob McGrew, Josh Tobin, OpenAI Pieter Abbeel, Wojciech Zaremba <br/> <strong>Code</strong>: <a href="https://github.com/openai/baselines/blob/master/baselines/her/README.md">https://github.com/openai/baselines/blob/master/baselines/her/README.md</a></p> </blockquote> <h1 id="background">Background</h1> <p>The combination of reinforcement learning and neural networks has achieved success in various domains involving sequential decision-making, such as Atari games, Go, and robot control tasks.</p> <p>Typically, in reinforcement learning tasks, a crucial aspect is designing a reward function that reflects the task itself and guides the optimization of the policy. Designing a reward function can be highly complex, which limits the application of reinforcement learning in the real world. It requires not only understanding of the algorithm itself but also substantial domain-specific knowledge. Moreover, in scenarios where it is difficult for us to determine what actions are appropriate, it is challenging to design an appropriate reward function. Therefore, algorithms that can learn policies from rewards that do not require explicit design, such as binary variables indicating task completion, are important for applications.</p> <p>One capability that humans possess but most model-free reinforcement learning algorithms lack is the ability to learn from “hindsight”. For example, if a basketball shot misses to the right, a reinforcement learning algorithm would conclude that the sequence of actions associated with the shot is unlikely to lead to success. However, an alternative “hindsight” conclusion can be drawn, namely that if the basket were slightly to the right (to the location where the ball landed), the same sequence of actions would result in success.</p> <p>The paper introduces a technique called Hindsight Experience Replay (HER), which can be combined with any off-policy RL algorithm. HER not only improves sampling efficiency but, more importantly, enables the algorithm to learn policies from binary and sparse rewards. HER incorporates the current state and a target state as inputs during replay, where the core idea is to replay an episode (a complete trajectory) using a different goal than the one the agent was originally trying to achieve.</p> <h1 id="her">HER</h1> <h2 id="1-an-introducing-example">1. An introducing example</h2> <p>Consider a coin flipping problem with a total of $n$ coins. The configuration of heads or tails for these $n$ coins represents a state, and the state space is denoted as $S={0,1}^n$. The action space is $A={0,1,…,n-1}$, where $i$ denotes flipping the i-th coin. In each episode, an initial state and a target state are uniformly and randomly selected. The RL policy flips these $n$ coins, and if the resulting state differs from the target state, a reward of $-1$ is obtained, i.e., $r_g(s,a)=-[s\neq g]$. Here, $g$ represents the target state.</p> <p>When $n&gt;40$, reinforcement learning strategies almost always fail because the policy rarely encounters rewards other than $-1$. Relying on random action exploration in such a large state space is impractical. A common approach in reinforcement learning is to design a reward function that guides the policy towards the goal. In this example, $r_g(s,a)=|s-g|^2$ can solve the problem. However, designing a reward function can be challenging, especially when facing more complex problems.</p> <p>The solution proposed in this paper does not require any domain-specific knowledge. Consider an episode that goes through a sequence of states $s_1, s_2, …, s_T$, and a target $g\neq s_1, s_2, …, s_T$ that has not been achieved. In each step of this episode, a reward of $-1$ is obtained. The method described in the paper involves replacing $g$ with $s_T$ and adding the modified episode to the replay buffer. This approach introduces paths with rewards different from $-1$, making the learning process simpler.</p> <p>Figure 1 compares the performance of plain DQN and DQN+HER in this environment. DQN without HER can solve problems with at most 13 coins, while DQN+HER can easily handle environments with 50 coins.</p> <p><img src="/assets/img/bit-flipping.png" alt="bit-flipping" width="500" height="300" style="margin-left: auto; margin-right: auto; display: block;"/></p> <figure> <figcaption style="text-align: center">Figure 1. Bit-flipping experiment w/o HER </figcaption> </figure> <h2 id="2-multi-goals-scenario">2. Multi-goals scenario</h2> <p>The problem scenario of interest involves an agent capable of achieving multiple distinct goals. Let’s assume there exists a set of goals $G$, where each goal $g\in G$ has a corresponding mapping $f_g:S\rightarrow {0,1}$, and the agent’s objective is to reach any state $s$ for which $f_g(s)=1$. For example, a goal could be a specific state itself: $f_g(s)=[s=g]$, or a goal related to a certain property of the state, such as reaching a given x-coordinate in a two-dimensional coordinate system: $f_g((x,y))=[x=g]$.</p> <p>Furthermore, the paper assumes that given a state $s$, it is straightforward to find a corresponding goal $g$. In other words, there exists a mapping $m:S\rightarrow G$ such that for every $s\in S$, $f_{m(s)}(s)=1$. For instance, in the case of a two-dimensional coordinate system, $m((x, y))=x$.</p> <p>Using a binary sparse reward function that assigns $-1$ if the goal is not achieved at each time step and 0 if it is achieved does not yield good results during actual training. This is because the reward is too sparse and lacks sufficient information. To address this problem, the original paper proposes the HER algorithm.</p> <h2 id="3-her-algorithm">3. HER algorithm</h2> <p>The idea behind HER is quite simple: after experiencing a sequence of states $s_1, s_2, …, s_T$, each transition $s_t\rightarrow s_{t+1}$ is saved. These transitions are not only associated with the original goal that generated the sequence but also grouped with a subset of other goals. Different goals only affect the agent’s actions and not the transition probabilities of the entire environment, allowing off-policy algorithms to use different goals during training.</p> <p>With HER, one task is to define the “subset of other goals.” The simplest approach, $m(s_T)$, involves using only the final state of a single trajectory as a goal.</p> <figure> <img src="/assets/img/her_algo.png" alt="HER algorithm"/> <figcaption style="text-align: center">Figure 2. HER algorithm </figcaption> </figure> <p>It’s worth noting that the algorithm of HER differs from a standard off-policy algorithm in a couple of ways. Firstly, the policy’s input is a concatenation of the state vector $s$ and the goal vector $g$. Secondly, the Replay Buffer stores not only the transition information generated through interactions with the environment but also the transition information after replacing the goal with a new goal $g’$. These pieces of information are collectively used for subsequent training.</p> <h1 id="experiment">Experiment</h1> <p>The paper’s experiments can be referenced in the following <a href="https://sites.google.com/site/hindsightexperiencereplay/">video</a>:</p> <p>The organization of the experimental section in the paper is as follows: The first part introduces the reinforcement learning environments used. Subsequently, each section explores the performance differences between DDPG with and without HER, the performance in single-goal scenarios, the impact of designing additional reward functions on performance, the influence of different sampling methods of goals on policy performance, and finally, the deployment of the algorithm on real robots.</p> <h2 id="1-environment">1. Environment</h2> <p>The paper used <code class="language-plaintext highlighter-rouge">Mujoco</code> and introduced its own environment, which has been made publicly available in the <a href="https://gym.openai.com/envs/#robotics">OpenAI Gym</a></p> <figure> <img src="/assets/img/mujoco_her.gif" alt="environments used"/> <figcaption style="text-align: center">Figure 3. Experiment environments </figcaption> </figure> <p>The policy is represented using a MLP with ReLU activation. The training utilizes the DDPG algorithm with the Adam optimizer.</p> <p>There are three tasks:</p> <ul> <li> <p><strong>Pushing</strong>: Pushing a box to a specified position on a table without performing the “grasp” action.</p> </li> <li> <p><strong>Slide</strong>: Sliding a ball to a target position on a smooth table that is outside the arm’s range of motion.</p> </li> <li> <p><strong>Pick and Place</strong>: Picking up a box and placing it at a designated airborne position.</p> </li> </ul> <p><strong>State</strong>:</p> <p>The state is represented by the Mujoco physics engine, including the angles and velocities of each robotic joint, as well as the positions, rotations, angular momentum, and linear momentum of all objects.</p> <p><strong>Goal</strong>:</p> <p>The goal is the desired position of the object, with a fixed tolerance $\epsilon$. For example, $G=R^3$, where $f_g(s)=[|g-s_{object}|\leq\epsilon]$, and $s_{object}$ represents the position of the object in state $s$. The mapping function is defined as $m(s)=s_{object}$.</p> <p><strong>Reward</strong>:</p> <p>Except for the section on <em>Reward Design Comparison</em>, the reward is defined as $r(s,a,g)=-[f_g(s’)=0]$, where $s’$ is the resulting state after performing action $a$ in state $s$.</p> <p><strong>Action</strong>:</p> <p>The action is four-dimensional, with the first three dimensions representing the desired relative position of the robotic gripper in the next time step, and the last dimension representing the desired distance between the two robotic fingers.</p> <h2 id="2-can-her-improve-performance">2. Can HER improve performance?</h2> <p>As shown in Figure 4, the performance of DDPG, DDPG with count-based exploration (Strehl and Littman, 2005; Kolter and Ng, 2009; Tang et al., 2016; Bellemare et al., 2016; Ostrovski et al., 2017), and DDPG+HER is compared. The blue line represents HER, which stores the transitions twice - once with the goal that generates interaction data with the environment and once with the goal changed to the state reached at the end of the episode. The red line is the best-performing HER strategy among the different goal selection strategies discussed in Section 5.</p> <figure> <img src="/assets/img/her_ddpg_multi_cmp.png" alt="HER performance comparison"/> <figcaption style="text-align: center">Figure 4. HER performance comparison, where the average results are taken from 5 random seeds, and the shadow represents one standard deviation. The red line represents the strategy using future sampling with k=4. </figcaption> </figure> <p>From Figure 4, we can observe that vanilla DDPG fails to learn the policies for all three tasks. DDPG with count-based exploration shows some progress only in the sliding task. However, DDPG+HER excels in solving all three tasks. It can be concluded that HER is crucial for learning policies from sparse and binary rewards.</p> <h2 id="3-can-her-improve-performance-when-there-is-only-one-goal">3. Can HER improve performance when there is only one goal?</h2> <p>In this section’s experiment, the goal for each episode is fixed to be the same (the same target position), repeating the experiment from Section 2. From Figure 5, it can be observed that DDPG+HER outperforms vanilla DDPG. Comparing Figure 4 and Figure 5, it is evident that HER learns faster when there are multiple goals. Therefore, the authors suggest that even if there is only one specific goal of interest, training can still be conducted using a multi-goal approach.</p> <figure> <img src="/assets/img/ddpg_her_single_cmp.png" alt="HER performance comparison"/> <figcaption style="text-align: center">Figure 5. HER single goal performance comparison </figcaption> </figure> <h2 id="4-how-does-her-interact-with-the-design-of-reward-functions">4. How does HER interact with the design of reward functions?</h2> <p>In this part, an attempt is made to design a reward function instead of using the binary sparse reward employed in the previous experiments. A shaped reward is considered: $r(s,a,g)=\lambda |g-s_{object} |^p-|g-s_{object}’ |^p$, where $s’$ represents the state reached after performing action $a$ in state $s$; $\lambda\in{0,1}$ and $p\in{1, 2}$ are hyperparameters.</p> <figure> <img src="/assets/img/her_reng.png" alt="HER performance comparison"/> <figcaption style="text-align: center">Figure 6. Performance comparison between HER and HER with designed reward functions. </figcaption> </figure> <p>From Figure 6, it can be observed that both vanilla DDPG and DDPG+HER did not learn effective policies. (This is possibly resulted from the fact that when applying reinforcement learning to complex manipulation tasks, it often requires designing reward functions that are much more complex than the ones attempted by the authors.)</p> <p>The authors believe that the failures stem from two reasons: 1. The optimization objective (shaped reward) differs significantly from the condition for success (whether the final position is within a certain radius of the target). 2. The shaped reward penalizes inappropriate actions, hindering exploration.</p> <p>While more complex reward designs may potentially address the issue, they require a substantial amount of domain knowledge. This fact reinforces the importance highlighted in the paper of effective learning from binary sparse rewards.</p> <h2 id="5-how-many-goals-should-be-chosen-and-how-should-they-be-selected">5. How many goals should be chosen and how should they be selected?</h2> <p>In previous experiments, only the final state of an episode was utilized. In this section, additional goal sampling methods are considered. The following methods are taken into account:</p> <ol> <li><strong>Final</strong>: The final state of an episode.</li> <li><strong>Random</strong>: Randomly select $k$ states encountered throughout the training process.</li> <li><strong>Episode</strong>: Randomly select $k$ states encountered within a single episode.</li> <li><strong>Future</strong>: Randomly select $k$ states that appear after the current state within the same episode.</li> </ol> <figure> <img src="/assets/img/goal_strats.png" alt="HER performance comparison"/> <figcaption style="text-align: center">Figure 7. Performance comparison of different goal selection methods. </figcaption> </figure> <p>As shown in Figure 7, the top row represents the highest success rate, while the bottom row represents the average success rate. The parameter $k$ controls the ratio between HER data in the Replay Buffer and the data generated by the agent’s interaction with the environment.</p> <p>It can be observed that for the third task, all goal selection methods except for Random perform remarkably well. Future combined with $k=4$ or $8$ shows the best performance across all tasks and is the only method that performs well in the second task. However, when $k$ exceeds $8$, there is a decline in performance, as the proportion of data generated by the agent’s interaction with the environment becomes relatively low.</p> <h2 id="6-deploy-on-a-real-robot">6. Deploy on a real robot</h2> <p>Lastly, the authors conducted an experiment where the algorithm (Future, $k=4$) was deployed on a real robot. They added a separately trained CNN layer to recognize camera images. In the initial five trials, the algorithm succeeded twice. However, after introducing noise to the observed data, all five trials were successful.</p> <h1 id="conclusion">Conclusion</h1> <p>The contributions of this paper is that:</p> <p>This paper proposes an innovative method that enables reinforcement learning algorithms to learn complex task policies from simple binary sparse rewards. This approach can be combined with any off-policy algorithm.</p> <h1 id="review-comments">Review comments</h1> <p>From <a href="https://proceedings.neurips.cc/paper/2017/file/453fadbd8a1a3af50a9df4df899537b5-Reviews.html">NeurIPS review</a>, one can see the questions raised by the reviewers regarding the original paper before its acceptance. Among them, one reasonable suggestion is to explore the combination of HER with a proven effective reward function for evaluating the performance of the combination of HER with reward engineering.</p> <h1 id="pytorch-implementation">Pytorch implementation</h1> <p>The article is very clear, with interesting ideas and a simple implementation. I personally really like this paper.</p> <p>Moreover, I attempted to implement HER myself, applying it to the <code class="language-plaintext highlighter-rouge">MountainCar-v0</code> environment in the Gym framework. In this environment, there is a single goal, and a reward of $-1$ is received at each time step until the goal is achieved. Without using HER, the typical approach is to rely on a large number of random actions to discover successful paths or to redesign the reward function. However, with DQN+HER, the policy can be learned relatively quickly, while vanilla DQN requires more time steps and more random exploration.</p> <figure> <img src="/assets/img/mountaincar-her.gif" alt="mountain car HER"/> <figcaption style="text-align: center">Mountain Car HER </figcaption> </figure> <p>So first import the necessary libraries:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span> 
<span class="kn">import</span> <span class="n">gym</span> 
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span> 
<span class="kn">import</span> <span class="n">torch.nn.functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="n">torch.optim</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">chain</span> 
<span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="n">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">'</span><span class="s">cpu</span><span class="sh">'</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="sh">'</span><span class="s">cuda:0</span><span class="sh">'</span><span class="p">)</span>
<span class="n">seed</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">makedirs</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">drl</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">DQN</span><span class="sh">'</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <p>We define an MLP policy:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MLPNet</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span> <span class="o">=</span> <span class="n">hidden_size</span> <span class="k">if</span> <span class="n">hidden_size</span> <span class="k">else</span> <span class="n">input_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="n">output_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">input_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">activation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hidden</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">hidden</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">output_size</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">classifier</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">mlp</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nf">module</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span> 


<span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">action_dim</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">,</span> <span class="n">is_discrete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Embedding</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_discrete</span> <span class="k">else</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="nc">MLPNet</span><span class="p">(</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">action_dim</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">embed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mlp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span>
</code></pre></div></div> <p>And Replay Buffer:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ReplayBuffer</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">replay_buffer_capacity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">RB</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span> <span class="o">=</span> <span class="n">replay_buffer_capacity</span>
        <span class="n">self</span><span class="p">.</span><span class="n">states</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">actions</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rewards</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">next_states</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dones</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer_capacity</span><span class="p">)</span>
        

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">states</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="nf">return </span><span class="p">(</span>
            <span class="n">self</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">actions</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">next_states</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">dones</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        trans: (state, action, reward, next_state, done)
        follows OpenAI gym
        </span><span class="sh">'''</span>
        <span class="n">self</span><span class="p">.</span><span class="n">states</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rewards</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">next_states</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dones</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div> <p>And HER:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HER</span><span class="p">(</span><span class="n">ReplayBuffer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">reward_func</span><span class="p">,</span> <span class="n">m_func</span><span class="p">,</span> <span class="n">sample_strategy</span> <span class="o">=</span> <span class="sh">'</span><span class="s">final</span><span class="sh">'</span><span class="p">,</span> <span class="n">k_goals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replay_buffer_capacity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">(</span><span class="n">replay_buffer_capacity</span><span class="o">=</span><span class="n">replay_buffer_capacity</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">reward_func</span> <span class="o">=</span> <span class="n">reward_func</span>
        <span class="n">self</span><span class="p">.</span><span class="n">m_func</span> <span class="o">=</span> <span class="n">m_func</span>
        <span class="k">if</span> <span class="n">sample_strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">'</span><span class="s">final</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">random</span><span class="sh">'</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">sample_strategy</span><span class="si">}</span><span class="s"> is not in [</span><span class="sh">'</span><span class="s">final</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">random</span><span class="sh">'</span><span class="s">]</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sample_strategy</span> <span class="o">=</span> <span class="n">sample_strategy</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">HER</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">k_goals</span> <span class="o">=</span> <span class="n">k_goals</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">goal</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        goal is a vector
        </span><span class="sh">'''</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="n">goal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_goal_size</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">goal</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">reward_func</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="n">size</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:])</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">ns</span><span class="p">,</span> <span class="n">goal</span><span class="p">])</span>
        <span class="c1"># print(f'append:{(s, a, r, ns, d)}')
</span>        <span class="nf">super</span><span class="p">().</span><span class="nf">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">hindsight</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ep_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        At the end of episode, append hindsight
        </span><span class="sh">'''</span>
        <span class="c1"># print(f'ep_len: {ep_len}')
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">sample_strategy</span> <span class="o">==</span> <span class="sh">'</span><span class="s">final</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">m_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">R_</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">k_goals</span><span class="p">):</span>
                <span class="n">R_tmp</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hindsight_append</span><span class="p">(</span><span class="n">ep_len</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
                <span class="n">R_</span> <span class="o">+=</span> <span class="n">R_tmp</span>
            <span class="n">R_</span> <span class="o">/=</span> <span class="n">self</span><span class="p">.</span><span class="n">k_goals</span>
            
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">sample_strategy</span> <span class="o">==</span> <span class="sh">'</span><span class="s">random</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">R_</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">k_goals</span><span class="p">):</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">))</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">m_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">R_</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hindsight_append</span><span class="p">(</span><span class="n">ep_len</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
            <span class="n">R_</span> <span class="o">/=</span> <span class="n">self</span><span class="p">.</span><span class="n">k_goals</span>
        <span class="k">return</span> <span class="n">R_</span>
    
    <span class="k">def</span> <span class="nf">hindsight_append</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ep_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_goal_size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">R_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">ep_len</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)])</span>
            <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">g</span> 
            <span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">reward_func</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="n">size</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">size</span><span class="p">:])</span>
            <span class="c1"># print(f'hindsight_append:{(s, a, r, ns, d)}')
</span>            <span class="nf">super</span><span class="p">().</span><span class="nf">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="n">tail</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">R_</span> <span class="o">+=</span> <span class="n">r</span> 
        
        <span class="k">return</span> <span class="n">R_</span><span class="p">,</span> <span class="n">tail</span>
    
    <span class="k">def</span> <span class="nf">_goal_size</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="p">.</span><span class="n">shape</span><span class="p">:</span>  <span class="c1"># np.array(1).shape -&gt; ()
</span>            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># np.array([1]).shape -&gt; (1,)
</span>        <span class="k">return</span> <span class="n">size</span>
</code></pre></div></div> <p>DQN:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BaseAgent</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">base</span><span class="sh">'</span>

    <span class="k">def</span> <span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">pass</span> 
    
<span class="k">class</span> <span class="nc">DQN</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">action_size</span><span class="p">,</span> <span class="n">goal_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                 <span class="n">replay_buffer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                 <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
                 <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                 <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                 <span class="n">cost</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">modules</span><span class="p">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MSELoss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="sh">'</span><span class="s">mean</span><span class="sh">'</span><span class="p">),</span>
                 <span class="n">lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
                 <span class="n">gradient_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">DQN</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">action_size</span> <span class="o">=</span> <span class="n">action_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span> <span class="o">=</span> <span class="n">replay_buffer</span> <span class="k">if</span> <span class="n">replay_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nc">ReplayBuffer</span><span class="p">(</span><span class="n">replay_buffer_capacity</span><span class="o">=</span><span class="mi">20000</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">is_her</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">HER</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="n">self</span><span class="p">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">epsilon</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">main_network</span> <span class="o">=</span> <span class="nc">Net</span><span class="p">(</span><span class="n">state_size</span><span class="p">,</span> <span class="n">action_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">is_discrete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">target_network</span> <span class="o">=</span> <span class="nc">Net</span><span class="p">(</span><span class="n">state_size</span><span class="p">,</span> <span class="n">action_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">is_discrete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">goal_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> 
            <span class="n">self</span><span class="p">.</span><span class="n">goal_size</span> <span class="o">=</span> <span class="n">goal_size</span>
            <span class="n">self</span><span class="p">.</span><span class="n">main_network</span> <span class="o">=</span> <span class="nc">Net</span><span class="p">(</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">goal_size</span><span class="p">,</span> <span class="n">action_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">is_discrete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">target_network</span> <span class="o">=</span> <span class="nc">Net</span><span class="p">(</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">goal_size</span><span class="p">,</span> <span class="n">action_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">is_discrete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="nc">Adam</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">main_network</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">gradient_steps</span> <span class="o">=</span> <span class="n">gradient_steps</span>

    <span class="k">def</span> <span class="nf">store_transition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        s, a, r, ns, d, (g if her)
        </span><span class="sh">'''</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
            <span class="n">trans_g</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">args</span><span class="p">]</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">trans_g</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">trans_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">epsilon_greedy</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">action_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">main_network</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">state</span><span class="p">)).</span><span class="nf">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">goal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">main_network</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">]))).</span><span class="nf">tolist</span><span class="p">()</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">action</span>

    <span class="k">def</span> <span class="nf">best_q_action</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">main_network</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">state</span><span class="p">)).</span><span class="nf">detach</span><span class="p">().</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">goal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span>
            <span class="n">s_g</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">])</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">main_network</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">s_g</span><span class="p">)).</span><span class="nf">detach</span><span class="p">().</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">action</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">batch_size</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="n">loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># minibatch = random.sample(self.replay_buffer, batch_size)
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">gradient_steps</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="nf">iter</span><span class="p">(</span><span class="n">loader</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># print(done)
</span>            <span class="n">max_tensor</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">target_network</span><span class="p">(</span><span class="n">ns</span><span class="p">).</span><span class="nf">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">target_Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">done</span><span class="p">.</span><span class="nf">long</span><span class="p">())</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">max_tensor</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">Q_values</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">main_network</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">Q_targets</span> <span class="o">=</span> <span class="n">Q_values</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
            <span class="n">Q_targets</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">Q_targets</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_Q</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">cost</span><span class="p">(</span><span class="n">Q_values</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">Q_targets</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
            <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_target_network</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target_network</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">main_network</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_preprocess_state</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">torch</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span>
            <span class="p">{</span><span class="sh">'</span><span class="s">main_network_sd</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">main_network</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">()},</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">main_network</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="sh">'</span><span class="s">main_network_sd</span><span class="sh">'</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target_network</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">main_network</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">())</span>

</code></pre></div></div> <p>The training and evaluating functions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">agent</span><span class="p">:</span> <span class="n">DQN</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_episodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">update_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">require_render</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">is_her</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">require_epsilon_explore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">save_path</span> <span class="o">=</span> <span class="n">save_path</span> <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">drl</span><span class="sh">'</span><span class="p">,</span> <span class="n">agent</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">time_step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cur_best</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">Return_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">agent</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
        <span class="n">is_her</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">is_her</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">goal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="sh">'</span><span class="s">goal</span><span class="sh">'</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">No env goal has been provided.</span><span class="sh">'</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">agent</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">DQN</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">require_epsilon_explore</span><span class="p">:</span>
            <span class="n">epsilon_decay</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">epsilon</span> <span class="o">-</span> <span class="mf">0.2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_episodes</span><span class="p">):</span>
            <span class="n">Return</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
            <span class="c1"># Cart-Pole
</span>            <span class="c1"># if np.mean(Return_list[-10:]) == 200:
</span>            <span class="c1">#     break
</span>            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_timesteps</span><span class="p">):</span>
                <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">require_render</span><span class="p">:</span>
                    <span class="n">env</span><span class="p">.</span><span class="nf">render</span><span class="p">()</span>
                <span class="n">time_step</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">time_step</span> <span class="o">%</span> <span class="n">agent</span><span class="p">.</span><span class="n">tau</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">agent</span><span class="p">.</span><span class="nf">update_target_network</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_her</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="nf">epsilon_greedy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="nf">epsilon_greedy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span>
                <span class="n">next_state</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_her</span><span class="p">:</span>
                    <span class="n">agent</span><span class="p">.</span><span class="nf">store_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">agent</span><span class="p">.</span><span class="nf">store_transition</span><span class="p">(</span><span class="n">state</span> <span class="p">,</span><span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">next_state</span>
                <span class="n">Return</span> <span class="o">+=</span> <span class="n">reward</span>
                <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_her</span><span class="p">:</span>
                        <span class="n">Return_</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">replay_buffer</span><span class="p">.</span><span class="nf">hindsight</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Episode:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">, Return_her:</span><span class="si">{</span><span class="n">Return_</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
                    <span class="n">Return_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">Return</span><span class="p">)</span>
                    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Episode:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">, Return:</span><span class="si">{</span><span class="n">Return</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">Return</span> <span class="o">&gt;=</span> <span class="n">cur_best</span><span class="p">:</span>
                        <span class="n">agent</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
                        <span class="n">cur_best</span> <span class="o">=</span> <span class="n">Return</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">steps</span> <span class="o">%</span> <span class="n">update_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">agent</span><span class="p">.</span><span class="nf">train</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">require_epsilon_explore</span><span class="p">:</span>
                <span class="n">agent</span><span class="p">.</span><span class="n">epsilon</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">num_episodes</span><span class="p">)</span> <span class="o">*</span> <span class="n">epsilon_decay</span> <span class="c1"># more exploitation
</span>        <span class="n">env</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">Return_list</span>
    
<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="n">require_render</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>    
    <span class="n">Return</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">agent</span><span class="p">.</span><span class="n">is_her</span><span class="p">:</span>
        <span class="n">is_her</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_her</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">is_her</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">goal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="sh">'</span><span class="s">goal</span><span class="sh">'</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">No env goal has been provided.</span><span class="sh">'</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">agent</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">DQN</span><span class="sh">'</span><span class="p">:</span>
        <span class="c1"># best action
</span>        
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_timesteps</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">require_render</span><span class="p">:</span>
                <span class="n">env</span><span class="p">.</span><span class="nf">render</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_her</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="nf">best_q_action</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">agent</span><span class="p">.</span><span class="nf">best_q_action</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span>
            <span class="n">next_state</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="n">Return</span> <span class="o">+=</span> <span class="n">reward</span>
            <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                
                <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Return:</span><span class="si">{</span><span class="n">Return</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="n">env</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Return</span>  
</code></pre></div></div> <p>Define the reward and $m$ of <code class="language-plaintext highlighter-rouge">MountainCar-v0</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reward_func_MountainCar</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    In the original code:
    done = bool(position &gt;= self.goal_position and velocity &gt;= self.goal_velocity)
    </span><span class="sh">'''</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>    

<span class="k">def</span> <span class="nf">m_MountainCar</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    m: S -&gt; G
    for MountainCar environment, s[0] is the position, s[1] is the velocity. The goal is s[0] == 0.5 and s[1] == 0
    </span><span class="sh">'''</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">g</span>
</code></pre></div></div> <p>Run experiment:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">MountainCar-v0</span><span class="sh">'</span>
<span class="n">env</span> <span class="o">=</span> <span class="n">gym</span><span class="p">.</span><span class="nf">make</span><span class="p">(</span><span class="n">env_name</span><span class="p">)</span>

<span class="n">her</span> <span class="o">=</span> <span class="nc">HER</span><span class="p">(</span><span class="n">reward_func</span><span class="o">=</span><span class="n">reward_func_MountainCar</span><span class="p">,</span> <span class="n">m_func</span><span class="o">=</span><span class="n">m_MountainCar</span><span class="p">,</span> <span class="n">sample_strategy</span><span class="o">=</span><span class="sh">'</span><span class="s">final</span><span class="sh">'</span><span class="p">,</span> <span class="n">replay_buffer_capacity</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">k_goals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">dqn_her</span> <span class="o">=</span> <span class="nc">DQN</span><span class="p">(</span><span class="n">state_size</span><span class="o">=</span><span class="n">env</span><span class="p">.</span><span class="n">observation_space</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">action_size</span><span class="o">=</span><span class="n">env</span><span class="p">.</span><span class="n">action_space</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="n">goal_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">replay_buffer</span><span class="o">=</span><span class="n">her</span><span class="p">,</span> <span class="n">gradient_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="p">.</span><span class="mi">001</span><span class="p">)</span>
<span class="n">dqn</span> <span class="o">=</span> <span class="nc">DQN</span><span class="p">(</span><span class="n">state_size</span><span class="o">=</span><span class="n">env</span><span class="p">.</span><span class="n">observation_space</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">action_size</span><span class="o">=</span><span class="n">env</span><span class="p">.</span><span class="n">action_space</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="n">gradient_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="p">.</span><span class="mi">001</span><span class="p">)</span>
<span class="n">save_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">drl</span><span class="sh">'</span><span class="p">,</span> <span class="n">dqn_her</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">env_name</span><span class="p">)</span> 

<span class="n">return_path_her</span> <span class="o">=</span> <span class="nf">train</span><span class="p">(</span><span class="n">dqn_her</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_episodes</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">update_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="n">num_tests</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Rs</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_tests</span><span class="p">):</span>
    <span class="n">Return</span> <span class="o">=</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">dqn_her</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">require_render</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="n">Rs</span> <span class="o">+=</span> <span class="n">Return</span>
<span class="nf">print</span><span class="p">(</span><span class="n">Rs</span> <span class="o">/</span> <span class="n">num_tests</span><span class="p">)</span>

<span class="c1"># In comparison
</span><span class="n">return_path_dqn</span> <span class="o">=</span> <span class="nf">train</span><span class="p">(</span><span class="n">dqn</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_episodes</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">update_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="n">num_tests</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Rs</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_tests</span><span class="p">):</span>
    <span class="n">Return</span> <span class="o">=</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">dqn</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">require_render</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">Rs</span> <span class="o">+=</span> <span class="n">Return</span>
<span class="nf">print</span><span class="p">(</span><span class="n">Rs</span> <span class="o">/</span> <span class="n">num_tests</span><span class="p">)</span>
</code></pre></div></div> <p>Check my post on Discovery Lab: <a href="https://mp.weixin.qq.com/s/CCDmxhc79WTWAnImsegvhQ">【每周一读】”事后诸葛亮”——一种简单有效的强化学习技术HER（文末附Pytorch代码）</a></p>]]></content><author><name></name></author><category term="RL"/><category term="HER"/><category term="Pytorch"/><summary type="html"><![CDATA[This week, I will share a paper published by OpenAI at NeurIPS 2017. The ideas presented in this paper are quite insightful, and it tackles a complex problem using only simple algorithmic improvements. I gained significant inspiration from this paper. At the end, I will also provide a brief implementation of HER (Hindsight Experience Replay).]]></summary></entry><entry><title type="html">What are the Effective Deep Learning Models for Tabular Data?</title><link href="https://bwfbowen.github.io/blog/2022/blog-tabulardl/" rel="alternate" type="text/html" title="What are the Effective Deep Learning Models for Tabular Data?"/><published>2022-03-13T00:00:00+00:00</published><updated>2022-03-13T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2022/blog-tabulardl</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2022/blog-tabulardl/"><![CDATA[<p>This week, I would like to share a paper published at NeurIPS 2021. When dealing with tabular data, I often find myself perplexed. On one hand, I am unsure which deep learning frameworks are better suited for this task, and on the other hand, I am uncertain whether the time-consuming process of training a model can outperform the easily accessible GBDT family of models such as XGBoost and LightGBM. However, this paper provides a detailed and comprehensive comparison of deep learning algorithms and GBDT models on tabular data. It introduces new baselines and presents a novel architecture that outperforms other deep learning models. I have gained a lot from this paper and would like to share it with you.</p> <blockquote> <p>Original Paper Information <br/> <strong>Title</strong>: Revisiting Deep Learning Models for Tabular Data <br/> <strong>Author</strong>: Yury Gorishniy, Ivan Rubachev, Valentin Khrulkov, Artem Babenko <br/> <strong>Code</strong>: <a href="https://github.com/yandex-research/rtdl">https://github.com/yandex-research/rtdl</a></p> </blockquote> <h1 id="background">Background</h1> <p>Deep learning has achieved significant success in the domains of image, audio, and text data, which has sparked interest in applying deep learning to tabular data. Tabular data refers to data points represented as vectors with diverse features, stored in a tabular form. Such data is commonly encountered in industrial applications and machine learning competitions.</p> <p>However, despite the proliferation of deep learning models applied to tabular data, previous studies lacked sufficient benchmarks and suffered from issues such as insufficient comparisons and inconsistent datasets. Additionally, while there have been novel architectures proposed in this field, there is still a lack of a simple, reliable, and competitive baseline. MLP remains the main baseline in this field, but it falls short in terms of competitiveness, despite its simplicity.</p> <p>Therefore, the authors compared mainstream deep learning models on various commonly used datasets with the same training framework. The authors also proposed two simple yet competitive frameworks: ResNet-like MLP, which is easy to tune but is outperformed by other models across multiple datasets, and FT-Transformer, which is a simple modification of the Transformer architecture and exhibits superior performance on the majority of datasets. Finally, the paper compared several state-of-the-art deep learning models with GBDT, concluding that neither approach is globally superior, and both have their strengths and weaknesses.</p> <h1 id="models-to-compare">Models to compare</h1> <p>\(\newcommand{\mlp}{\mathrm{MLP}} \newcommand{\mlpb}{\mathrm{MLPBlock}} \newcommand{\lin}{\mathrm{Linear}} \newcommand{\drop}{\mathrm{Dropout}} \newcommand{\relu}{\mathrm{ReLU}} \newcommand{\resn}{\mathrm{ResNet}} \newcommand{\resb}{\mathrm{ResNetBlock}} \newcommand{\pred}{\mathrm{Prediction}} \newcommand{\bn}{\mathrm{BatchNorm}} \newcommand{\stack}{\mathrm{stack}} \newcommand{\fttrans}{\mathrm{FT-Transformer}} \newcommand{\fttb}{\mathrm{Block}} \newcommand{\ft}{\mathrm{FeatureTokenizer}} \newcommand{\ffn}{\mathrm{FFN}} \newcommand{\rpn}{\mathrm{ResidualPreNorm}} \newcommand{\norm}{\mathrm{Norm}} \newcommand{\act}{\mathrm{Activation}} \newcommand{\module}{\mathrm{Module}} \newcommand{\mhsa}{\mathrm{MHSA}} \newcommand{\acls}{\mathrm{AppendCLS}} \newcommand{\layern}{\mathrm{LayerNorm}}\) This section describes the models used for comparison. There are some symbols and concepts that need to be clarified:</p> <p>The paper focuses on supervised learning problems. $D={(x_i,y_i)}$ represents the dataset, where $x_i=(x_i^{num},x_i^{cat})$ represents the numerical and categorical features respectively, and $yi$ represents the corresponding labels. There are a total of $k$ features. The dataset is divided into three disjoint subsets: $D=D_{train} \cup D_{val} \cup D_{test}$. $D_{train}$ is used for model training, $D_{val}$ is used for hyperparameter tuning and early stopping, and $D_{test}$ is used for final evaluation.</p> <p>The tasks encompass three types: binary classification, regression, and multi-class classification.</p> <h2 id="1-mlp">1. MLP</h2> <p>Each Multilayer Perceptron (MLP) block consists of three parts:</p> <ol> <li>One linear layer;</li> <li>ReLU activation;</li> <li>Dropout layer.</li> </ol> <p>Multiple MLP blocks are nested together, and the output is passed through a final linear layer. \(\mlp(x)=\lin(\mlpb(...(\mlpb(x))))\)</p> <h2 id="2-resnet-like-mlp">2. ResNet-like MLP</h2> <p>The paper introduces a simple variant of ResNet, and the structure of the ResNet model in the paper is as follows: \(\begin{align} \resn(x) &amp; =\pred(\resb(...(\resb(\lin(x))))) \\ \resb(x) &amp; =x+\drop(\lin(\drop(\relu(\lin(\bn(x)))))) \\ \pred(x) &amp; =\lin(\relu(\bn(x))) \end{align}\) It consists of multiple nested residual blocks, followed by batch normalization, ReLU activation, and a linear layer for output. Each residual block includes batch normalization, a linear layer, ReLU activation, Dropout, another linear layer, Dropout, and a residual connection.</p> <h2 id="3-ft-transformer">3. FT-Transformer</h2> <p>The authors proposed the FT-Transformer (Feature Tokenizer Transformer) architecture, as shown below. It consists of two parts: the first part involves mapping all the features to embedding vectors, while the second part applies a series of Transformer blocks to these vectors.</p> <figure> <img src="/assets/img/fttrans.png" alt="ft-transformer"/> <figcaption style="text-align: center">Figure 1. In the FT-Transformer architecture, the first step is to map all the features to vectors through an embedding process. Then, a special token, [CLS], is added to the mapped vectors to serve as the final prediction of the model. </figcaption> </figure> <p>The Feature Tokenizer block performs a linear transformation and adds bias on numerical features, with independent weights for each numerical feature. For categorical variables, each category is mapped to a distinct vector, and the categorical variables are treated independently. This process results in a $k\times d$-dimensional vector $T$. The formula can be expressed as follows: \(\begin{align} &amp; T_j^{(num)} = b_j^{(num)}+x_j \cdot W_j^{(num)} &amp; \in \mathbb{R}^d,\\ &amp; T_j^{(cat)} = b_j^{(cat)}+e_j^TW_j^{(cat)} &amp; \in\mathbb{R}^d, \\ &amp; T = \stack[T_1^{(num)},...,T_{k^{(num)}}^{(num)},T_1^{(cat)},...,T_{k^{(cat)}}^{(cat)}] &amp; \in \mathbb{R}^{k\times d}. \end{align}\)</p> <p>The Transformer block starts by adding a [CLS] token to the beginning of the vector $T$. Each block in the Transformer consists of a multi-head self-attention and a feed-forward network. Both parts of the block undergo layer normalization and residual connections. \(\begin{align} \fttrans(x)&amp;=\pred(\fttb(...(\fttb(\acls(\ft(x)))))) \\ \fttb(x)&amp;=\rpn(\ffn,\rpn(\mhsa,x)) \\ \rpn(\module, x) &amp;= x + \drop(\module(\norm(x))) \\ \ffn(x) &amp;= \lin(\drop(\act(\lin(x)))) \end{align}\) The final prediction is made using the extracted [CLS] vector after passing through multiple layers, which are layer normalization, ReLU activation, and a linear layer. \(\hat{y}=\lin(\relu(\layern(T_L^{[CLS]}))).\)</p> <figure> <img src="/assets/img/fttrans_struct.png" alt="ft-transformer"/> <figcaption style="text-align: center">Figure 2. (a) is Feature Tokenizer, (b) is one Transformer block. </figcaption> </figure> <h2 id="4-other-models">4. Other models</h2> <p>In this section, the authors briefly mention several models: SNN, NODE, TabNet, GrowNet, DCN V2, AutoInt, XGBoost, and CatBoost.</p> <p>It is mentioned in the appendix that <a href="https://github.com/Qwicen/node">NODE</a>, <a href="https://github.com/google-research/google-research/tree/master/tabnet">TabNet</a>, and <a href="https://github.com/sbadirli/GrowNet">GrowNet</a> utilize official open-source implementations. As for the other deep learning models, they were implemented by the authors themselves, and the source code can be found in their <a href="https://github.com/yandex-research/rtdl">open-source repository</a>.</p> <h1 id="experiments">Experiments</h1> <h2 id="1-datasets">1. Datasets</h2> <p>Apart from Appendix, 11 publicly available datasets are compared in the paper. Each dataset undergoes a single data split, and all models are trained, validated, and tested on the exact same data to ensure fair comparison.</p> <figure> <img src="/assets/img/data_cmp_rtdl.png" alt="datasets"/> <figcaption style="text-align: center">Figure 3. For the 11 datasets, the evaluation metric for regression problems is the root mean square error (RMSE), while for binary classification and multi-class classification, the evaluation metric is accuracy. The terms "num. features" and "cat. features" represent the number of numerical features and categorical features, respectively. </figcaption> </figure> <h2 id="2-implementation-details">2. Implementation details</h2> <ul> <li>Preprocessing: <ul> <li>Data preprocessing has a significant impact on the performance of deep learning models. By default, the quantile transform from <code class="language-plaintext highlighter-rouge">scikit-learn</code> is used. Normalization is applied to the <code class="language-plaintext highlighter-rouge">Helena</code> and <code class="language-plaintext highlighter-rouge">ALOI</code> datasets, while for the Epsilon dataset, it was found that preprocessing had a detrimental effect, so the original data was used. The regression targets are standardized.</li> </ul> </li> <li>Hyperparameter Tuning: <ul> <li>Hyperparameters are tuned using a validation set. The authors mention the use of the <code class="language-plaintext highlighter-rouge">Optuna</code> tool for Bayesian optimization, which has been shown to outperform random search (Turner et al., 2021). The comparisons in the main body of the paper are limited to a specific number of iterations, and comparisons with limited time are provided in the appendix.</li> </ul> </li> <li>Evaluation: <ul> <li>The experiments are run with different random seeds, and the performance on the test set is averaged over 15 runs.</li> </ul> </li> <li>Ensemble Methods: <ul> <li>Ensemble methods are considered in the experiments. For each model, the 15 individual models are divided into three disjoint groups, and the outputs of the models within each group are averaged.</li> </ul> </li> <li>Neural Networks: <ul> <li>For classification problems, cross-entropy loss is used, while for regression problems, mean squared error is used. <code class="language-plaintext highlighter-rouge">TabNet</code> and <code class="language-plaintext highlighter-rouge">GrowNet</code> follow the original papers and use the <code class="language-plaintext highlighter-rouge">Adam</code> optimizer, while the others use <code class="language-plaintext highlighter-rouge">AdamW</code>. All models terminate training if there is no improvement on the validation set for 17 consecutive epochs.</li> </ul> </li> <li>Handling Categorical Variables: <ul> <li>For <code class="language-plaintext highlighter-rouge">XGBoost</code>, one-hot encoding is used, while <code class="language-plaintext highlighter-rouge">CatBoost</code> utilizes its built-in methods for categorical variable handling. For neural networks, embeddings of the same dimensions are used, following the approach described in the <code class="language-plaintext highlighter-rouge">FT-Transformer</code>.</li> </ul> </li> </ul> <h2 id="3-result">3. Result</h2> <h3 id="31-deep-learning-models-comparison">3.1 Deep learning models comparison</h3> <p>The result is shown below:</p> <figure> <img src="/assets/img/dl_cmp_rtdl.png" alt="deep learning models comparison"/> <figcaption style="text-align: center">Figure 4. Deep learning models comparison. Bold indicates the best-performing model for each task. </figcaption> </figure> <p>To summarize,</p> <ol> <li> <p>MLP remains a good sanity check.</p> </li> <li> <p>ResNet serves as an effective baseline, as no other model consistently outperforms it.</p> </li> <li> <p>Fine-tuning can make MLP and ResNet competitive, so the authors recommend tuning the parameters of the baselines when feasible. They also mention the helpfulness of Optuna in parameter tuning.</p> </li> <li> <p>Next, the authors found that the NODE model performs well on multiple tasks. However, it has a larger parameter count compared to ResNet and FT-Transformer, and it employs a framework similar to ensemble learning. Therefore, the authors further compared the performance of NODE, ResNet, and FT-Transformer using ensembling.</p> </li> </ol> <figure> <img src="/assets/img/ensemble_dl_rtdl.png" alt="Ensemble deep learning models comparison"/> <figcaption style="text-align: center">Figure 5. Ensemble deep learning models comparison. Bold indicates the best-performing model for each task. </figcaption> </figure> <p>It can be observed that ResNet and FT-Transformer benefit more from ensembling, while NODE’s improvement is relatively smaller. Additionally, FT-Transformer consistently outperforms the NODE model.</p> <h3 id="32-deep-learning-vs-gbdt">3.2 Deep learning vs GBDT</h3> <p>In this section, all deep learning models are compared with GBDT models in ensemble ways. The results are as follows:</p> <figure> <img src="/assets/img/gbdt_dl_rtdl.png" alt="Ensemble deep learning models vs GBDT"/> <figcaption style="text-align: center">Figure 6. Ensemble deep learning models and GBDT models comparison. Bold indicates the best-performing model for each task. </figcaption> </figure> <p>The authors compared the performance of default and tuned parameters. The performance of default parameters is important since it is a common scenario in practice. It can be seen that the ensemble of FT-Transformer with default parameters performs on par with the tuned FT-Transformer.</p> <p>After tuning the parameters, GBDT dominates in some datasets, and the difference in performance is significant. This indicates that there is no general superiority between deep learning and GBDT. However, for multi-class classification problems with a larger number of classes, GBDT is not particularly suitable. For example, in the case of Helena with 100 classes, GBDT’s performance after tuning is unsatisfactory, and for ALOI with 1000 classes, the training process is slow and it becomes challenging to tune the GBDT model.</p> <p>The default parameters of FT-Transformer is given in the Appendix:</p> <figure> <img src="/assets/img/dparam_fttrans_rtdl.png" alt="Default parameters of FT-Transformer"/> <figcaption style="text-align: center">Figure 7. The default parameter of FT-Transformer. </figcaption> </figure> <h2 id="4-inspiring-question-when-is-ft-transformer-better-than-resnet">4. Inspiring question: When is FT-Transformer better than ResNet?</h2> <p>The author observed that on datasets where GBDT outperforms ResNet, FT-Transformer also exhibits a larger advantage over ResNet. On other datasets, the performance of the two models is relatively close, which the author observed in both single-model and ensemble settings.</p> <p>Therefore, the author conducted a series of synthetic tasks to demonstrate when FT-Transformer is better than ResNet, ranging from negligible performance difference to significant gaps.</p> <p>First, the author generated and fixed a series of data points ${x_i}$ and performed a single train-validate-test split. Two regression targets were defined: $f_{GBDT}$, which is expected to be simpler for GBDT, and $f_{DL}$, which is expected to be simpler for ResNet. The definitions are as follows:</p> \[x\sim \mathcal{N}(0,I_k), \\ y=\alpha f_{GBDT}(x)+(1-\alpha)f_{DL}(x).\] <p>where $f_{GBDT}(x)$ is the average output of 30 randomly generated decision trees, $f_{DL}(x)$ is an MLP with 3 randomly initialized layers. The target $y$ is normalized before training.</p> <figure> <img src="/assets/img/syn_cmp_rtdl.png" alt="FT-Transformer vs ResNet"/> <figcaption style="text-align: center">Figure 8. 5 experiment results on test set, each alpha represents a task. </figcaption> </figure> <p>It can be observed that on tasks that are simpler for ResNet (small $\alpha$), both deep learning models outperform CatBoost. However, as the tasks become more GBDT-friendly (large $\alpha$), the performance of the ResNet model significantly declines. On the other hand, FT-Transformer exhibits competitive performance across all tasks.</p> <p>This experiment demonstrates that FT-Transformer is better than ResNet at fitting functions that are based on decision trees. This finding may be related to the previous observations.</p> <h2 id="5-ablation-experiments">5. Ablation Experiments</h2> <p>In this section, the author conducted several ablation experiments on the implementation choices of FT-Transformer.</p> <p>First, the author compared the AutoInt model, which also maps features to embedding vectors and utilizes self-attention. However, there are differences in the implementation details. AutoInt does not include biases during feature mapping, and its core structure differs significantly from the architecture described in Vaswani et al., 2017, the canonical Transformer. Additionally, AutoInt does not utilize techniques such as adding [CLS] during inference.</p> <p>Using the same procedure as before, the author examined the performance without adding biases, as shown in the figure:</p> <figure> <img src="/assets/img/ablation_rtdl.png" alt="Ablation Transformer"/> <figcaption style="text-align: center">Figure 9. 2 attention mechanism and w/o feature biases comparison. </figcaption> </figure> <p>It can be observed that the core of Transformer is better than AutoInt, and including feature biases yields better results compared to excluding them.</p> <h2 id="conclusion">Conclusion</h2> <p>This paper provides a comprehensive comparison of mainstream deep learning models on multiple tabular datasets and improves the baseline standards for deep learning on tabular data. Firstly, it demonstrates the effectiveness of ResNet-like architectures as strong baselines. Secondly, it introduces FT-Transformer, which outperforms other deep learning models on the majority of datasets. Thirdly, through the comparison of deep learning models with GBDT, it reveals that GBDT still dominates on certain datasets.</p> <h2 id="appendix">Appendix</h2> <p>In the appendix, there is still a wealth of noteworthy information. It includes the parameter spaces for hyperparameter tuning of each model, which is not elaborated here. Instead, I will highlight some additional experiments.</p> <h3 id="training-time">Training Time</h3> <p>Firstly, the authors present a comparison of the training time between ResNet and FT-Transformer on the 11 datasets discussed:</p> <figure> <img src="/assets/img/time_cmp_rtdl.png" alt="Training time comparison"/> <figcaption style="text-align: center">Figure 10. Training time comparison of FT-Transformer and ResNet-like MLP in seconds. The huge difference on Yahoo(YA) dataset might be resulted from large feature size. </figcaption> </figure> <p>Next, the authors attempted to limit the tuning time and observe the performance of different models. In this experiment, XGBoost, MLP, ResNet, and FT-Transformer were used. The experiment was conducted on three datasets: California Housing, Adult, and Higgs Small. The results are as follows:</p> <figure> <img src="/assets/img/tlimit_cmp_rtdl.png" alt="Limit training time comparison"/> <figcaption style="text-align: center">Figure 11. The number of iterations for tuning with Optuna is indicated in parentheses. The red bold font represents the best performance among all models, while the black bold font represents the best performance among the deep learning models. </figcaption> </figure> <p>It can be observed that:</p> <ol> <li>FT-Transformer performs well in a few rounds of random parameter selection (within the first 10 rounds of default random selection with Optuna).</li> <li>FT-Transformer has a slower training speed compared to other models.</li> <li>Additional iterations have limited significance for other models.</li> </ol> <h3 id="other-datasets">Other datasets</h3> <p>The appendix provides the performance of different models on four datasets that were not mentioned in the main text. The author found that all models perform similarly on these datasets, but the limited information provided does not warrant their inclusion in the main text. The four datasets are as follows:</p> <figure> <img src="/assets/img/other_rtdl.png" alt="Other datasets for comparison"/> <img src="/assets/img/other_cmp_rtdl.png" alt="Other datasets for comparison"/> <figcaption style="text-align: center">Figure 12. Additonal datasets. </figcaption> </figure> <h2 id="review-comments">Review comments</h2> <p>From the <a href="https://openreview.net/forum?id=i_Q1yrOegLY">openreview</a>, we can see the questions raised by the reviewers before the paper was accepted. Some of the answers to these questions are already reflected in the appendix, such as the changes in model performance over time and the datasets like “click.” However, I would like to highlight the question regarding the selection of GBDT models.</p> <p>One comment mentioned that both XGBoost and CatBoost use level-wise trees, and it would be interesting to explore the use of leaf-wise trees like LightGBM.</p> <p>The author provided experiment results on LightGBM:</p> <figure> <img src="/assets/img/lightgbm_rtdl.png" alt="LightGBM for comparison"/> <figcaption style="text-align: center">Figure 13. Comparison of LightGBM and other models on CA, AD, HI datasets. </figcaption> </figure> <p>CA and AD are datasets where GBDT performs well, and HI is a dataset where deep learning and GBDT perform similarly. For CA, lower values are better, while higher values are better for the other two. It can be observed that LightGBM performs similarly to the other two GBDT models, which aligns with the author’s expectations.</p> <p>The author mentioned that deep learning models were not able to surpass GBDT on datasets that are more favorable to GBDT. Therefore, additional GBDT models were not included. However, if deep learning models start to outperform some GBDT models on datasets that are more GBDT-friendly, it would be necessary to include more GBDT models for comparison.</p> <h1 id="implementation">Implementation</h1> <p>The article provides a comprehensive comparison and answers questions that have long puzzled me. Yandex is a Russian search giant, and CatBoost is also from this company, which is worth paying attention to.</p> <p>At the same time, I have learned two new things: FT-Transformer and Optuna. I have tried both tools personally, and I would like to share the code for each.</p> <p><code class="language-plaintext highlighter-rouge">ft_transformer.py</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">unicodedata</span> <span class="kn">import</span> <span class="n">name</span>
<span class="kn">from</span> <span class="n">gzip</span> <span class="kn">import</span> <span class="n">GzipFile</span>
<span class="kn">import</span> <span class="n">torch</span> 
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span> 
<span class="kn">from</span> <span class="n">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="n">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">quantile_transform</span>
<span class="kn">from</span> <span class="n">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">accuracy_score</span> 
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span> 
<span class="kn">import</span> <span class="n">os</span> 
<span class="kn">from</span> <span class="n">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span> 
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">class</span> <span class="nc">PositionalEncoding</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">d_model</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">PositionalEncoding</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">dropout</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">d_model</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">div_term</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d_model</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="nf">float</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mf">10000.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">d_model</span><span class="p">))</span>
        <span class="n">pe</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">position</span> <span class="o">*</span> <span class="n">div_term</span><span class="p">)</span>
        <span class="n">pe</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">position</span> <span class="o">*</span> <span class="n">div_term</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="n">pe</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">register_buffer</span><span class="p">(</span><span class="sh">'</span><span class="s">pe</span><span class="sh">'</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        x: [sequence length, batch size, embed dim]
        output: [sequence length, batch size, embed dim]
        </span><span class="sh">'''</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">pe</span><span class="p">[:</span><span class="n">x</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">cats_data</span><span class="p">,</span> <span class="n">numers_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cats_data</span> <span class="o">=</span> <span class="n">cats_data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numers_data</span> <span class="o">=</span> <span class="n">numers_data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">cats_data</span><span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">cats_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">numers_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span>         


<span class="k">class</span> <span class="nc">NumerFeatureTokenizer</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">feature_dim</span><span class="p">,</span> 
        <span class="n">embedding_dim</span><span class="p">,</span>
        <span class="n">device</span>
        <span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span> <span class="o">=</span> <span class="n">feature_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">embedding_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizers</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">([</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">feature_dim</span><span class="p">)])</span>
    

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x_numer</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        x_numer: [batch size, feature dim]
        output: [batch size, feature dim, embedding dim]
        </span><span class="sh">'''</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x_numer</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span> <span class="o">==</span> <span class="n">x_numer</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="sh">'</span><span class="s">特征大小不等</span><span class="sh">'</span>
        <span class="n">x_numer</span> <span class="o">=</span> <span class="n">x_numer</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">x_numer</span><span class="p">.</span><span class="n">device</span>
        <span class="n">tensor_embed</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tensor_embed</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x_numer</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">])</span>
             
        <span class="k">return</span> <span class="n">tensor_embed</span>


<span class="k">class</span> <span class="nc">CatFeatureTokenizer</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">max_cats</span><span class="p">,</span> 
        <span class="n">embedding_dim</span><span class="p">,</span>
        <span class="n">device</span>
        <span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">max_cats</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">embedding_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizers</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">([</span><span class="n">nn</span><span class="p">.</span><span class="nc">Embedding</span><span class="p">(</span><span class="n">max_cats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">embedding_dim</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span><span class="p">)])</span>
    

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x_cat</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        x_cat: [batch size, feature dim]
        output: [batch size, feature dim, embedding dim]
        </span><span class="sh">'''</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x_cat</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span> <span class="o">==</span> <span class="n">x_cat</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="sh">'</span><span class="s">特征大小不等</span><span class="sh">'</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">x_cat</span><span class="p">.</span><span class="n">device</span>
        <span class="n">tensor_embed</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">embedding_dim</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">feature_dim</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tensor_embed</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizers</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x_cat</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
             
        <span class="k">return</span> <span class="n">tensor_embed</span>


<span class="k">class</span> <span class="nc">TransformerClassifier</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span> 
        <span class="n">num_classes</span><span class="p">,</span>
        <span class="n">cat_tokenizer</span><span class="p">:</span> <span class="n">CatFeatureTokenizer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">numer_tokenizer</span><span class="p">:</span> <span class="n">NumerFeatureTokenizer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">nhead</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
        <span class="n">dim_feedforward</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">dim_feedforward_size_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">dropout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">num_layers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
        <span class="n">batch_first</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">TransformerClassifier</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span> <span class="o">=</span> <span class="n">cat_tokenizer</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span> <span class="o">=</span> <span class="n">numer_tokenizer</span>

        <span class="k">if</span> <span class="n">cat_tokenizer</span> <span class="ow">and</span> <span class="n">numer_tokenizer</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span> <span class="o">==</span> <span class="n">numer_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="sh">'</span><span class="s">inconsistent tokenizer dimensions</span><span class="sh">'</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">elif</span> <span class="n">cat_tokenizer</span><span class="p">:</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">elif</span> <span class="n">numer_tokenizer</span><span class="p">:</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">numer_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">at least one tokenizer is needed</span><span class="sh">'</span><span class="p">)</span>

        
        <span class="k">assert</span> <span class="n">d_model</span> <span class="o">%</span> <span class="n">nhead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">'</span><span class="s">d_model % nhead != 0</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">d_model</span> <span class="o">=</span> <span class="n">d_model</span>
        <span class="k">if</span> <span class="n">dim_feedforward</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dim_feedforward</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">dim_feedforward_size_factor</span> <span class="o">*</span> <span class="n">d_model</span><span class="p">)</span>
        <span class="n">encoder_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">TransformerEncoderLayer</span><span class="p">(</span><span class="n">batch_first</span><span class="o">=</span><span class="n">batch_first</span><span class="p">,</span> <span class="n">d_model</span><span class="o">=</span><span class="n">d_model</span><span class="p">,</span> <span class="n">nhead</span><span class="o">=</span><span class="n">nhead</span><span class="p">,</span> <span class="n">dim_feedforward</span><span class="o">=</span><span class="n">dim_feedforward</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">transformer_encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">TransformerEncoder</span><span class="p">(</span><span class="n">encoder_layer</span><span class="p">,</span> <span class="n">num_layers</span><span class="o">=</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">d_model</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        x: (x_cats, x_numer) tuple; or x_cats/ x_numer tensor
        shape: [batch_size, feature_dim, embedding_dim]
        output: [batch_size, num_classes]
        </span><span class="sh">'''</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span><span class="p">:</span>
                <span class="n">x_cats</span><span class="p">,</span> <span class="n">x_numer</span> <span class="o">=</span> <span class="n">x</span> 
                <span class="n">x_cats</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">cat_tokenizer</span><span class="p">(</span><span class="n">x_cats</span><span class="p">)</span>
                <span class="n">x_numer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">numer_tokenizer</span><span class="p">(</span><span class="n">x_numer</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">x_cats</span><span class="p">,</span> <span class="n">x_numer</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Tokenizer not found</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">cat_tokenizer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">numer_tokenizer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
        <span class="n">device</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">device</span>      
        <span class="n">cls</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">d_model</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
        <span class="c1"># self.temp = x 
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">transformer_encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># self.tmp = x 
</span>        <span class="c1"># x = x.mean(dim=1)
</span>        <span class="n">cls</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">activation</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">classifier</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span>


<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">TransformerClassifier</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">save_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">model</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">transformer_val_best_model</span><span class="sh">'</span><span class="p">),</span> <span class="n">is_lstm</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="n">loss_trace</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_val_loss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">best_val_score</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">)):</span>
        <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
        <span class="n">current_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
            <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span>  <span class="o">=</span> <span class="n">x_cat_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_lstm</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)))</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
            <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
            <span class="n">current_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>
        <span class="n">loss_trace</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_loss</span><span class="p">)</span>

        <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
        <span class="n">val_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">val_score</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
        <span class="n">pred_val</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span> <span class="ow">in</span> <span class="n">val_loader</span><span class="p">:</span>
            
                <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span>  <span class="o">=</span> <span class="n">x_cat_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_lstm</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)))</span>
                <span class="n">pred_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
                <span class="n">pred_val</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pred_batch</span><span class="p">)</span>
                <span class="n">val_score</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">y_batch</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span>
                <span class="n">val_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>
            <span class="c1"># val_loss = np.mean(val_loss)
</span>        
        <span class="n">val_score</span> <span class="o">=</span> <span class="nf">accuracy_score</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">val_score</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">pred_val</span><span class="p">))</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s"> </span><span class="se">\n</span><span class="s"> val loss: </span><span class="si">{</span><span class="n">val_loss</span><span class="si">}</span><span class="s"> </span><span class="se">\t</span><span class="s"> train loss: </span><span class="si">{</span><span class="n">current_loss</span><span class="si">}</span><span class="s"> </span><span class="se">\n</span><span class="s"> val score: </span><span class="si">{</span><span class="n">val_score</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">val_loss</span> <span class="o">&lt;</span> <span class="n">best_val_loss</span> <span class="ow">or</span> <span class="n">val_score</span> <span class="o">&gt;</span> <span class="n">best_val_score</span><span class="p">:</span>
            <span class="n">torch</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sh">'</span><span class="s">epoch</span><span class="sh">'</span><span class="p">:</span> <span class="n">epoch</span><span class="p">,</span>
                <span class="sh">'</span><span class="s">model_state_dict</span><span class="sh">'</span><span class="p">:</span> <span class="n">model</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">(),</span>
                <span class="sh">'</span><span class="s">best_val_loss</span><span class="sh">'</span><span class="p">:</span> <span class="n">val_loss</span><span class="p">,</span>
                <span class="sh">'</span><span class="s">best_val_score</span><span class="sh">'</span><span class="p">:</span> <span class="n">val_score</span>
            <span class="p">},</span> 
            <span class="n">save_to</span>
            <span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">model saved</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val_loss</span> <span class="o">&lt;</span> <span class="n">best_val_loss</span><span class="p">:</span>
                <span class="n">best_val_loss</span> <span class="o">=</span> <span class="n">val_loss</span>
            <span class="k">if</span> <span class="n">val_score</span> <span class="o">&gt;</span> <span class="n">best_val_score</span><span class="p">:</span>
                <span class="n">best_val_score</span> <span class="o">=</span> <span class="n">val_score</span>

        <span class="n">torch</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sh">'</span><span class="s">epoch</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">last</span><span class="sh">'</span><span class="p">,</span>
                <span class="sh">'</span><span class="s">model_state_dict</span><span class="sh">'</span><span class="p">:</span> <span class="n">model</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">()</span>
            <span class="p">},</span> 
            <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">model</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">transformer_last_epoch</span><span class="sh">'</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="c1"># loss curve
</span>    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_epochs</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">loss_trace</span><span class="p">,</span> <span class="sh">'</span><span class="s">r-</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Epoch</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Loss</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>  
        

<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_loader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">is_lstm</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c1"># to_load = os.path.join('model', 'transformer_val_best_model')
</span>    <span class="c1"># model.load_state_dict(torch.load(to_load)['model_state_dict'])
</span>    <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
    <span class="n">pred_result</span><span class="p">,</span> <span class="n">true_result</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(),</span> <span class="nf">deque</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">test_loader</span><span class="p">):</span>    
            <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span>  <span class="o">=</span> <span class="n">x_cat_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_lstm</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)))</span>
            <span class="n">pred_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
            <span class="n">pred_result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pred_batch</span><span class="p">)</span>
            <span class="n">true_result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">y_batch</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>

    <span class="n">true_result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">true_result</span><span class="p">)</span>
    <span class="n">pred_result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">pred_result</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">classification_report</span><span class="p">(</span><span class="n">true_result</span><span class="p">,</span> <span class="n">pred_result</span><span class="p">))</span> 
    <span class="n">score</span> <span class="o">=</span> <span class="nf">accuracy_score</span><span class="p">(</span><span class="n">true_result</span><span class="p">,</span> <span class="n">pred_result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">score</span>
    

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">"</span><span class="s">cuda:0</span><span class="sh">"</span> <span class="k">if</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="sh">"</span><span class="s">cpu</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">makedirs</span><span class="p">(</span><span class="sh">'</span><span class="s">model</span><span class="sh">'</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="nc">GzipFile</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sh">'</span><span class="s">covtype.data.gz</span><span class="sh">'</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Xy</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Xy</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">x_numers</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">10</span><span class="p">]</span>

        <span class="n">x_cats</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">10</span><span class="p">:]</span>
        <span class="n">x_cat1</span> <span class="o">=</span> <span class="n">x_cats</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">].</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">copy</span><span class="p">()</span>
        <span class="n">x_cat2</span> <span class="o">=</span> <span class="n">x_cats</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:].</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">copy</span><span class="p">()</span>
        <span class="n">x_cat</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">([</span><span class="n">x_cat1</span><span class="p">,</span> <span class="n">x_cat2</span><span class="p">]).</span><span class="n">T</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
        <span class="n">test_ratio</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="n">val_ratio</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_test</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_c_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="nf">train_test_split</span><span class="p">(</span><span class="n">x_numers</span><span class="p">,</span> <span class="n">x_cat</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_ratio</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span>
        <span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_c_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="nf">train_test_split</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">val_ratio</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span>

        <span class="n">preprocess_n</span> <span class="o">=</span> <span class="nc">StandardScaler</span><span class="p">().</span><span class="nf">fit</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">)</span>
        <span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">x_n_test</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_val</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_test</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">train_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_n_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">val_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_val</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
        <span class="n">test_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_test</span><span class="p">,</span> <span class="n">x_n_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">256</span>
        <span class="n">train_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="n">val_loader</span><span class="o">=</span>  <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">test_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">)</span>

        <span class="n">embedding_dim</span> <span class="o">=</span> <span class="mi">192</span>
        <span class="n">cft</span> <span class="o">=</span> <span class="nc">CatFeatureTokenizer</span><span class="p">(</span><span class="n">max_cats</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="nc">NumerFeatureTokenizer</span><span class="p">(</span><span class="n">feature_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="nc">TransformerClassifier</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">cat_tokenizer</span><span class="o">=</span><span class="n">cft</span><span class="p">,</span> <span class="n">numer_tokenizer</span><span class="o">=</span><span class="n">nft</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0001</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">CrossEntropyLoss</span><span class="p">()</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span> <span class="o">=</span> <span class="n">lr</span><span class="p">)</span>

        <span class="nf">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="nf">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_loader</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">FileNotFoundError</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Data not found.</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>As for <code class="language-plaintext highlighter-rouge">optuna.ipynb</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">optuna</span>
<span class="kn">import</span> <span class="n">torch</span>  <span class="c1"># torch.__version__ &gt;= 1.9.0
</span><span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span> 
<span class="kn">from</span> <span class="n">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="n">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="n">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">accuracy_score</span> 
<span class="kn">from</span> <span class="n">gzip</span> <span class="kn">import</span> <span class="n">GzipFile</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">import</span> <span class="n">os</span> 
<span class="kn">from</span> <span class="n">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span> 
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="n">ft_transformer</span> <span class="kn">import</span> <span class="n">NumerFeatureTokenizer</span><span class="p">,</span> <span class="n">CatFeatureTokenizer</span><span class="p">,</span> <span class="n">TransformerClassifier</span>

<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">"</span><span class="s">cuda:0</span><span class="sh">"</span> <span class="k">if</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="sh">"</span><span class="s">cpu</span><span class="sh">"</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="nf">makedirs</span><span class="p">(</span><span class="sh">'</span><span class="s">model</span><span class="sh">'</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>
</code></pre></div></div> <p>Read and pre-process the data</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">genfromtxt</span><span class="p">(</span><span class="nc">GzipFile</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sh">'</span><span class="s">covtype.data.gz</span><span class="sh">'</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">Xy</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Xy</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="n">x_numers</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">x_cats</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">10</span><span class="p">:]</span>
<span class="n">x_cat1</span> <span class="o">=</span> <span class="n">x_cats</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">].</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">copy</span><span class="p">()</span>
<span class="n">x_cat2</span> <span class="o">=</span> <span class="n">x_cats</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:].</span><span class="nf">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">copy</span><span class="p">()</span>
<span class="n">x_cats</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">([</span><span class="n">x_cat1</span><span class="p">,</span> <span class="n">x_cat2</span><span class="p">]).</span><span class="n">T</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

<span class="n">test_ratio</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">val_ratio</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_test</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_c_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="nf">train_test_split</span><span class="p">(</span><span class="n">x_numers</span><span class="p">,</span> <span class="n">x_cats</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_ratio</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span>
<span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_c_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="nf">train_test_split</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_c_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">val_ratio</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_train</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span>

<span class="n">preprocess_n</span> <span class="o">=</span> <span class="nc">StandardScaler</span><span class="p">().</span><span class="nf">fit</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">)</span>
<span class="n">x_n_train</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">x_n_test</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_train</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_val</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">preprocess_n</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">x_n_test</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

</code></pre></div></div> <p>Dataloader:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">cats_data</span><span class="p">,</span> <span class="n">numers_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cats_data</span> <span class="o">=</span> <span class="n">cats_data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numers_data</span> <span class="o">=</span> <span class="n">numers_data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">cats_data</span><span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">cats_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">numers_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span>   

<span class="n">train_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_train</span><span class="p">,</span> <span class="n">x_n_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">val_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_val</span><span class="p">,</span> <span class="n">x_n_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
<span class="n">test_dataset</span> <span class="o">=</span> <span class="nc">CatNumerDataset</span><span class="p">(</span><span class="n">x_c_test</span><span class="p">,</span> <span class="n">x_n_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">train_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">)</span>
<span class="n">val_loader</span><span class="o">=</span>  <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
<span class="n">test_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">)</span>

<span class="c1">#  subset of dataset for tutorial
</span><span class="n">subset_train_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randperm</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">))[:</span><span class="mi">3000</span><span class="p">]</span>
<span class="n">subset_val_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randperm</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">))[:</span><span class="mi">3000</span><span class="p">]</span>
<span class="n">train_sampler</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">SubsetRandomSampler</span><span class="p">(</span><span class="n">subset_train_indices</span><span class="p">)</span>
<span class="n">val_sampler</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">SubsetRandomSampler</span><span class="p">(</span><span class="n">subset_val_indices</span><span class="p">)</span>
<span class="n">subset_train_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">train_sampler</span><span class="p">)</span>
<span class="n">subset_val_loader</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">val_sampler</span><span class="p">)</span>
</code></pre></div></div> <p>Supportive functions for <code class="language-plaintext highlighter-rouge">optuna</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">classes</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">in_features</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">max_cats</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build_fttransformer</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">feature_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_cats</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">192</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_int</span><span class="p">(</span><span class="sh">'</span><span class="s">embedding_dim</span><span class="sh">'</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">dropout</span> <span class="o">=</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_float</span><span class="p">(</span><span class="sh">'</span><span class="s">dropout</span><span class="sh">'</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    
    <span class="n">cft</span> <span class="o">=</span> <span class="nc">CatFeatureTokenizer</span><span class="p">(</span><span class="n">max_cats</span><span class="o">=</span><span class="n">max_cats</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nft</span> <span class="o">=</span> <span class="nc">NumerFeatureTokenizer</span><span class="p">(</span><span class="n">feature_dim</span><span class="o">=</span><span class="n">feature_dim</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="nc">TransformerClassifier</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">cat_tokenizer</span><span class="o">=</span><span class="n">cft</span><span class="p">,</span> <span class="n">numer_tokenizer</span><span class="o">=</span><span class="n">nft</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>

<span class="c1">#  MLP model
</span><span class="k">class</span> <span class="nc">MLPClassifier</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
                 <span class="n">cat_tokenizer</span><span class="p">:</span> <span class="n">CatFeatureTokenizer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                 <span class="n">numer_tokenizer</span><span class="p">:</span> <span class="n">NumerFeatureTokenizer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">MLPClassifier</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span> <span class="o">=</span> <span class="n">cat_tokenizer</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span> <span class="o">=</span> <span class="n">numer_tokenizer</span>
        
        <span class="k">if</span> <span class="n">cat_tokenizer</span> <span class="ow">and</span> <span class="n">numer_tokenizer</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span> <span class="o">==</span> <span class="n">numer_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="sh">'</span><span class="s">Inconsistent tokenizer dimensions</span><span class="sh">'</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">elif</span> <span class="n">cat_tokenizer</span><span class="p">:</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">cat_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">elif</span> <span class="n">numer_tokenizer</span><span class="p">:</span>
            <span class="n">d_model</span> <span class="o">=</span> <span class="n">numer_tokenizer</span><span class="p">.</span><span class="n">embedding_dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">At least one tokenizer is required</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">d_model</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span> <span class="o">=</span> <span class="n">hidden_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">layers</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_layers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">input_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_size</span><span class="p">))</span>
            <span class="n">self</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">activation</span><span class="p">)</span>
            
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">
        x: (x_cats, x_numer) tuple; or x_cats/ x_numer tensor
        shape: [batch_size, feature_dim, embedding_dim]
        output: [batch_size, num_classes]
        </span><span class="sh">'''</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span><span class="p">:</span>
                <span class="n">x_cats</span><span class="p">,</span> <span class="n">x_numer</span> <span class="o">=</span> <span class="n">x</span> 
                <span class="n">x_cats</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">cat_tokenizer</span><span class="p">(</span><span class="n">x_cats</span><span class="p">)</span>
                <span class="n">x_numer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">numer_tokenizer</span><span class="p">(</span><span class="n">x_numer</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">hstack</span><span class="p">([</span><span class="n">x_cats</span><span class="p">,</span> <span class="n">x_numer</span><span class="p">])</span>  <span class="c1"># hstack available in version 1.8.0
#                 x = torch.cat([x_cats, x_numer], dim=1)
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Tokenizer not found</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">cat_tokenizer</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">cat_tokenizer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">numer_tokenizer</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">numer_tokenizer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
        <span class="n">device</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">device</span>      
        
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nf">module</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y_pred</span> 

<span class="k">def</span> <span class="nf">build_mlp</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">feature_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">192</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">):</span>
    
    <span class="n">cft</span> <span class="o">=</span> <span class="nc">CatFeatureTokenizer</span><span class="p">(</span><span class="n">max_cats</span><span class="o">=</span><span class="n">max_cats</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nft</span> <span class="o">=</span> <span class="nc">NumerFeatureTokenizer</span><span class="p">(</span><span class="n">feature_dim</span><span class="o">=</span><span class="n">feature_dim</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="o">=</span><span class="n">embedding_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># We optimize the number of layers.
</span>    <span class="n">n_layers</span> <span class="o">=</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_int</span><span class="p">(</span><span class="sh">"</span><span class="s">n_layers</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="nc">MLPClassifier</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="n">n_layers</span><span class="p">,</span> <span class="n">cat_tokenizer</span><span class="o">=</span><span class="n">cft</span><span class="p">,</span> <span class="n">numer_tokenizer</span><span class="o">=</span><span class="n">nft</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>

<span class="k">def</span> <span class="nf">build_model</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
    <span class="n">model_name</span> <span class="o">=</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_categorical</span><span class="p">(</span><span class="sh">'</span><span class="s">model_name</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">mlp</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">fttransformer</span><span class="sh">'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">mlp</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">build_mlp</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">in_features</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">fttransformer</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">build_fttransformer</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">in_features</span><span class="p">,</span> <span class="n">max_cats</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">train_evaluate</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">)):</span>
        <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
        <span class="n">current_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
            <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span>  <span class="o">=</span> <span class="n">x_cat_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)))</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
            <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
            <span class="n">current_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>

        <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
        <span class="n">val_score</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
        <span class="n">pred_val</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span> <span class="ow">in</span> <span class="n">val_loader</span><span class="p">:</span>
            
                <span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">,</span> <span class="n">y_batch</span>  <span class="o">=</span> <span class="n">x_cat_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">x_cat_batch</span><span class="p">,</span> <span class="n">x_numer_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)))</span>
                <span class="n">pred_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
                <span class="n">pred_val</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">pred_batch</span><span class="p">)</span>
                <span class="n">val_score</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">y_batch</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">y_batch</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span>
        
        <span class="n">val_score</span> <span class="o">=</span> <span class="nf">accuracy_score</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">val_score</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="n">pred_val</span><span class="p">))</span>

        <span class="n">trial</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="n">val_score</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trial</span><span class="p">.</span><span class="nf">should_prune</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">optuna</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="nc">TrialPruned</span><span class="p">()</span>
            
    <span class="k">return</span> <span class="n">val_score</span> 

<span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">trial</span><span class="p">):</span>
    
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">lr</span><span class="sh">'</span><span class="p">:</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_loguniform</span><span class="p">(</span><span class="sh">'</span><span class="s">lr</span><span class="sh">'</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">optimizer_name</span><span class="sh">'</span><span class="p">:</span> <span class="n">trial</span><span class="p">.</span><span class="nf">suggest_categorical</span><span class="p">(</span><span class="sh">'</span><span class="s">optimizer</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">AdamW</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Adam</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">SGD</span><span class="sh">'</span><span class="p">]),</span>
    <span class="p">}</span>
    <span class="n">model</span> <span class="o">=</span> <span class="nf">build_model</span><span class="p">(</span><span class="n">trial</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    
    <span class="n">optimizer</span> <span class="o">=</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="sh">'</span><span class="s">optimizer_name</span><span class="sh">'</span><span class="p">])(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="sh">'</span><span class="s">lr</span><span class="sh">'</span><span class="p">])</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">CrossEntropyLoss</span><span class="p">()</span>
    <span class="n">score</span> <span class="o">=</span> <span class="nf">train_evaluate</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">subset_train_loader</span><span class="p">,</span> <span class="n">subset_val_loader</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">score</span> 

</code></pre></div></div> <p>Run experiments:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">study</span> <span class="o">=</span> <span class="n">optuna</span><span class="p">.</span><span class="nf">create_study</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="sh">'</span><span class="s">maximize</span><span class="sh">'</span><span class="p">)</span>
<span class="n">study</span><span class="p">.</span><span class="nf">optimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>

<span class="n">pruned_trials</span> <span class="o">=</span> <span class="n">study</span><span class="p">.</span><span class="nf">get_trials</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="p">[</span><span class="n">optuna</span><span class="p">.</span><span class="n">trial</span><span class="p">.</span><span class="n">TrialState</span><span class="p">.</span><span class="n">PRUNED</span><span class="p">])</span>
<span class="n">complete_trials</span> <span class="o">=</span> <span class="n">study</span><span class="p">.</span><span class="nf">get_trials</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="p">[</span><span class="n">optuna</span><span class="p">.</span><span class="n">trial</span><span class="p">.</span><span class="n">TrialState</span><span class="p">.</span><span class="n">COMPLETE</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Study statistics: </span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Number of finished trials: </span><span class="sh">"</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">study</span><span class="p">.</span><span class="n">trials</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Number of pruned trials: </span><span class="sh">"</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">pruned_trials</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Number of complete trials: </span><span class="sh">"</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">complete_trials</span><span class="p">))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Best trial:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">trial</span> <span class="o">=</span> <span class="n">study</span><span class="p">.</span><span class="n">best_trial</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Value: </span><span class="sh">"</span><span class="p">,</span> <span class="n">trial</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Params: </span><span class="sh">"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">trial</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">    {}: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
</code></pre></div></div> <p>Check my post on Discovery Lab: <a href="https://mp.weixin.qq.com/s/iFX9CiEFmIn9hARKIwGtUQ">【每周一读】重提表格数据上的深度学习</a></p>]]></content><author><name></name></author><category term="DL"/><category term="Tabular Data"/><category term="Pytorch"/><category term="Transformer"/><summary type="html"><![CDATA[This week, I would like to share a paper published at NeurIPS 2021. When dealing with tabular data, I often find myself perplexed. On one hand, I am unsure which deep learning frameworks are better suited for this task, and on the other hand, I am uncertain whether the time-consuming process of training a model can outperform the easily accessible GBDT family of models such as XGBoost and LightGBM. However, this paper provides a detailed and comprehensive comparison of deep learning algorithms and GBDT models on tabular data. It introduces new baselines and presents a novel architecture that outperforms other deep learning models. I have gained a lot from this paper and would like to share it with you.]]></summary></entry><entry><title type="html">Will DRL Make Profit in High-Frequency Trading?</title><link href="https://bwfbowen.github.io/blog/2021/blog-drlhft/" rel="alternate" type="text/html" title="Will DRL Make Profit in High-Frequency Trading?"/><published>2021-10-21T00:00:00+00:00</published><updated>2021-10-21T00:00:00+00:00</updated><id>https://bwfbowen.github.io/blog/2021/blog-drlhft</id><content type="html" xml:base="https://bwfbowen.github.io/blog/2021/blog-drlhft/"><![CDATA[<p>Can deep reinforcement learning algorithms be used to train a trading agent that can achieve long-term profitability using Limit Order Book (LOB) data? To answer this question, this article proposes a deep reinforcement learning framework for high-frequency trading and conducts experiments using limit order data from <a href="https://lobsterdata.com">LOBSTER</a> with the PPO algorithm. The results show that the agent is able to identify short-term patterns in the data and propose profitable trading strategies.</p> <blockquote> <p>Original Paper Information <br/> <strong>Title</strong>: Deep Reinforcement Learning for Active High Frequency Trading <br/> <strong>Author</strong>: Antonio Briola, Jeremy Turiel, Riccardo Marcaccioli, Tomaso Aste <br/> <strong>DOI</strong>: arXiv:2101.07107</p> </blockquote> <h1 id="background">Background</h1> <h2 id="limit-order-book">Limit Order Book</h2> <p>A Limit Order Book (LOB) records the outstanding limit orders in the current market. A limit order is an order with a specified price that is not lower than the specified price. The LOB data used in the article refers to the ten-level market data, which includes the top ten buy and sell prices with the highest priority, as well as the total order quantity at each price level. The difference between the best bid price and the best ask price is referred to as the bid-ask spread.</p> <figure> <img src="/assets/img/lob-drlhft.png" alt="A demonstration of LOB data"/> <figcaption style="text-align: center">Figure 1. A demonstration of LOB data </figcaption> </figure> <p>Traders buy or sell securities by sending instructions to the exchange in the form of limit orders or market orders. These instructions are stored in two separate queues based on the buy or sell direction until they are either canceled or executed. Each order, denoted as $x$, contains four pieces of information: buy/sell direction ($\epsilon_x$), limit price ($p_x$), order quantity ($V_x$), and order arrival time ($τ_x$). Currently, most exchanges employ a price-time priority rule, where higher bid orders have priority over lower bid orders, and lower ask orders have priority over higher ask orders. For orders with the same price, the order that arrives first is given priority. Market orders, on the other hand, bypass the bid-ask spread and are typically executed immediately, at the cost of bearing the crossing spread as a trading cost. Therefore, the bid-ask spread is referred to as the trading cost for market orders.</p> <h2 id="ppo">PPO</h2> <p>The PPO algorithm is a type of Policy Gradient algorithm and falls under the category of on-policy methods. Compared to previous algorithms such as REINFORCE, PPO improves by controlling the update step size of the policy to prevent it from being too large, which could cause the model to collapse, or too small, which could result in excessively long training times. PPO inherits the idea of controlling policy updates from TRPO but offers easier implementation and lower computational complexity, surpassing TRPO in performance. PPO also has different implementation variants, with the clip-based approach being more common. The objective function for PPO with the clip-based approach is as follows: \(\newcommand{\clip}{\mathrm{clip}}\) \(\begin{align} L(\theta) &amp; = \mathbb{E}_t[\min(r_t(\theta)A_t, \clip(r_t(\theta),1-\epsilon,1+\epsilon)A_t)] \\ r_t(\theta) &amp; = \frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t)} \end{align}\)</p> <p>Where $A_t$ represents the advantage function, which is a function of the action and state. It is defined as the difference between the Q-value of action $a$ and the value of state $s$ under the policy $\pi$. It reflects the performance of action $a$ compared to the average. $\pi$ represents the policy, and $θ$ represents the parameters of the policy network, which outputs the probability of selecting action $a$ given state $s$. $r_t$ represents the ratio of the probabilities of the new policy and the old policy. The clip function ensures that $r_t$ does not exceed the range $[1-ε, 1+ε]$.</p> <p>The interpretation is as follows: when $A &gt; 0$, it indicates that action a has an advantage over other actions, so the policy network should increase the output probability of action $a$, which means increasing $r_t$. However, $r_t$ should not exceed $1+ε$. When $A &lt; 0$, it indicates that action $a$ is at a disadvantage compared to other actions, so the network should decrease the output probability, but not below $1-ε$.</p> <h1 id="method">Method</h1> <h2 id="data">Data</h2> <p>The data used in this paper comes from <a href="https://lobsterdata.com/">LOBSTER</a>, which provides tick-by-tick and snapshot data for all stocks on the NASDAQ exchange. The snapshot data of INTC was used for the subsequent experiments because, relatively speaking, trading in large stocks is more active and price changes are more dependent on the information in LOB. The duration of the data used is 60 trading days, with the training set covering the period from 2019/02/04 to 2019/04/30, the validation set covering 2019/05/01 to 2019/05/31, and the test set covering 2019/06/03 to 2019/06/28. Due to the instability during the opening and closing periods, the data for the initial and last 2*10^5 ticks of each trading day were excluded.</p> <h2 id="model">Model</h2> <p>3 different state definitions are tested, which are:</p> <ul> <li>$s_{201}$: current and most recent 9 ticks 10-level buy-sell volume and current long/short state;</li> <li>$s_{202}$: $s_{201}+$ current profit earned if closing position (current price - opening price, spread considered);</li> <li>$s_{203}$: $s_{202}+$ current spread</li> </ul> <p>4 actions (\(\mathcal{A}=\{0:sell, 1:stay, 2:long, 3:daily\ stop\ loss\}\)) for the agent, which based on the state of the position(\(\mathcal{P}=\{N:neutral,L:long,S:short\}\)), result in different effect:</p> <figure> <img src="/assets/img/action-drlhft.png" alt="Action effects"/> <figcaption style="text-align: center">Figure 2. Action effects </figcaption> </figure> <p>Regardless of whether there is a position or not, Action 1 does nothing. If there is no current position, Actions 0 and 2 respectively initiate a sell and buy of the minimum trading unit, entering a short and long position. Regardless of whether there is a position or not, Action 3 calculates the cumulative profit at the current moment. If it is less than 0, the position is closed; otherwise, no action is taken. If the current position is short, Action 0 does nothing, and Action 2 buys the minimum trading unit to close the short position and calculates the trading profit. If the current position is long, Action 2 does nothing, and Action 0 sells to close the long position and calculates the trading profit.</p> <p>The calculation of trading profit, as defined in this paper, is based on the position entered at time ($\tau - t$) and closed at time $\tau$, and the profit is calculated as follows:</p> \[R_{l/s}=p^{best}_{a/b,\tau}-p^{best}_{b/a,\tau-t}\] <p>Where $l/s$ represents long and short, \(p^{best}_{a,\tau},p^{best}_{b,\tau}\) represents the best ask and bid price at time $\tau$.</p> <p>Note that the model proposed trades and holds only one unit of stock asset at each time point. This assumption is made for several reasons: trading itself can impact the Limit Order Book (LOB), larger trades may cause significant changes in the mid-price; larger trading orders are typically split into multiple smaller orders for execution; and introducing a variable for the number of units traded would require a more complex model.</p> <h2 id="pipeline">Pipeline</h2> <p>In the training phase, for each trading day, a window of $10^4$ consecutive ticks is selected, and 5 segments with the largest absolute mid-price changes are chosen. From all the segments, 25 are selected to form the vectorized DRL environment. Each environment undergoes 30 epochs of iteration.</p> <p>The reason for this approach is that the paper believes larger price changes offer more opportunities for trading actions.</p> <p>The agent policy and value network share parameters and are implemented as a 2-hidden-layer MLP, with separate outputs for action $a$ and value $V$.</p> <p>In the validation phase, Bayesian optimization is used to tune the model hyperparameters, based on the cumulative returns on the validation set, to determine the next set of parameters. The validation set is processed in the same way as the training set.</p> <p>In the testing phase, the strategy is independently tested on each day, and trading returns are recorded for plotting the Profit and Loss (P&amp;L) curve.</p> <h1 id="result">Result</h1> <p>The following figures depict the performance of the agent on the test set. They include the cumulative P&amp;L curve over the entire test set, the daily average P&amp;L and standard deviation across different iteration rounds, and the distribution of returns for each trade conducted by the agent.</p> <figure> <img src="/assets/img/pnl-drlhft.png" alt="PnL"/> <figcaption style="text-align: center">Figure 3. The test set results are presented from left to right as follows: cumulative returns on the test set, daily average returns and standard deviation, and the distribution of trade returns. </figcaption> </figure> <p>From top to bottom, they correspond to the three different states proposed in the model: 201/202/203. On average, the agent can achieve profitable trading strategies without considering trading costs. Comparing the three different states, the information introduced in state 202 significantly improves trading performance compared to state 201. However, state 203 does not show further improvement over state 202.</p> <p>From the second column, it can be observed that there are more positive return trading days than negative return trading days, and the realized returns are not concentrated on specific trading days. They are also not affected by intraday cyclic factors.</p> <p>From the third column, it can be seen that due to the intraday stop-loss action (action 3), the tails of negative returns are truncated. The number of trades in state 202 is significantly higher than in states 201/203.</p> <h1 id="comment">Comment</h1> <p>This paper demonstrates an approach to applying deep reinforcement learning models to high-frequency trading. It compares and explores the impact of different state designs on out-of-sample performance and discovers that introducing mark-to-market (realizing profits upon closing a position) can enhance the performance of the agent.</p> <p>The article may have an error in the definition of trading profits. I believes that the correct definition should be \(R_{i,\tau}=\begin{cases} p^{best}_{b,\tau}-p^{best}_{\alpha,\tau-t} &amp; \text{if } i=l \\ p^{best}_{b,\tau-t}-p^{best}_{\alpha, \tau} &amp; \text{if } i=s \end{cases}\)</p> <p>In order to achieve immediate execution at the prevailing bid/ask spread, the definition of trading profits should be adjusted accordingly.</p> <p>The paper does not discuss trading delays. Given the trading hours of NASDAQ from 9:30 am to 4:00 pm and the volume of 300,000 ticks of data (as indicated by the x-axis in the second column of the results), it is important to consider the issue of latency when actions are executed.</p> <p>Furthermore, the article only utilizes “volume” data for the first 200 dimensions of the state design. It may be interesting to explore the impact of incorporating some “price” information, such as the average opening price over the past 5 days, on the performance of the model.</p> <p>My question pertains to the observed imbalance in action distribution, where a large number of actions result in either no change (1) or the same direction (0 or 2). While the preprocessing method employed in the article’s training set partially addresses this issue, I wonder if there are other approaches to mitigate this problem.</p> <p>Check my post on Discovery Lab: <a href="https://mp.weixin.qq.com/s/xN9AlVERzp1aKz3Adh_NTw">【每周一读】深度强化学习在高频交易上的应用</a></p>]]></content><author><name></name></author><category term="RL"/><category term="HFT"/><category term="LOB"/><summary type="html"><![CDATA[Can deep reinforcement learning algorithms be used to train a trading agent that can achieve long-term profitability using Limit Order Book (LOB) data? To answer this question, this article proposes a deep reinforcement learning framework for high-frequency trading and conducts experiments using limit order data from LOBSTER with the PPO algorithm. The results show that the agent is able to identify short-term patterns in the data and propose profitable trading strategies.]]></summary></entry></feed>